
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text Green Screen - Viral Edit Pro</title>
    <link rel="stylesheet" href="shared.css">
    <style>
        /* Additional font imports for text green screen */
        @import url('https://fonts.googleapis.com/css2?family=Bebas+Neue&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Oswald:wght@200;300;400;500;600;700&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@100;200;300;400;500;600;700;800;900&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Raleway:wght@100;200;300;400;500;600;700;800;900&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Anton&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@100;300;400;500;700;900&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Lato:wght/100;300;400;700;900&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;500;600;700;800;900&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;500;600;700;800;900&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=League+Gothic:wght@400&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Michroma:wght@400&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Prompt:wght@100;200;300;400;500;600;700;800;900&display=swap');
        
        /* Local Custom Fonts */
        @font-face { font-family: 'Grammastile'; src: url('fonts/3616-grammastile-app.otf') format('opentype'); }
        @font-face { font-family: 'Atalanta'; src: url('fonts/Atalanta-Regular.otf') format('opentype'); }
        @font-face { font-family: 'De Valencia'; src: url('fonts/De Valencia (beta).otf') format('opentype'); }
        @font-face { font-family: 'Ducados'; src: url('fonts/ducados.otf') format('opentype'); }
        @font-face { font-family: 'Evolventa'; src: url('fonts/Evolventa-Regular.otf') format('opentype'); font-weight: 400; }
        @font-face { font-family: 'Evolventa'; src: url('fonts/Evolventa-Bold.otf') format('opentype'); font-weight: 700; }
        @font-face { font-family: 'Evolventa'; src: url('fonts/Evolventa-Oblique.otf') format('opentype'); font-style: italic; }
        @font-face { font-family: 'Evolventa'; src: url('fonts/Evolventa-BoldOblique.otf') format('opentype'); font-weight: 700; font-style: italic; }
        @font-face { font-family: 'FFF Nepsza'; src: url('fonts/FFF_NEPSZA-BADSAG-Bold.otf') format('opentype'); font-weight: 700; }
        @font-face { font-family: 'Grotesk 812'; src: url('fonts/Grotesk812-CondensedMedium.ttf') format('truetype'); }
        @font-face { font-family: 'Humane'; src: url('fonts/Humane-Thin.otf') format('opentype'); font-weight: 100; }
        @font-face { font-family: 'Humane'; src: url('fonts/Humane-ExtraLight.otf') format('opentype'); font-weight: 200; }
        @font-face { font-family: 'Humane'; src: url('fonts/Humane-Light.otf') format('opentype'); font-weight: 300; }
        @font-face { font-family: 'Humane'; src: url('fonts/Humane-Regular.otf') format('opentype'); font-weight: 400; }
        @font-face { font-family: 'Humane'; src: url('fonts/Humane-Medium.otf') format('opentype'); font-weight: 500; }
        @font-face { font-family: 'Humane'; src: url('fonts/Humane-SemiBold.otf') format('opentype'); font-weight: 600; }
        @font-face { font-family: 'Humane'; src: url('fonts/Humane-Bold.otf') format('opentype'); font-weight: 700; }
        @font-face { font-family: 'Kenney Blocks'; src: url('fonts/Kenney Blocks.ttf') format('truetype'); }
        @font-face { font-family: 'Kenney Future'; src: url('fonts/Kenney Future.ttf') format('truetype'); }
        @font-face { font-family: 'Kenney Future Narrow'; src: url('fonts/Kenney Future Narrow.ttf') format('truetype'); }
        @font-face { font-family: 'Kenney High'; src: url('fonts/Kenney High.ttf') format('truetype'); }
        @font-face { font-family: 'Kenney High Square'; src: url('fonts/Kenney High Square.ttf') format('truetype'); }
        @font-face { font-family: 'Kenney Mini'; src: url('fonts/Kenney Mini.ttf') format('truetype'); }
        @font-face { font-family: 'Kenney Mini Square'; src: url('fonts/Kenney Mini Square.ttf') format('truetype'); }
        @font-face { font-family: 'Kenney Pixel'; src: url('fonts/Kenney Pixel.ttf') format('truetype'); }
        @font-face { font-family: 'Kenney Pixel Square'; src: url('fonts/Kenney Pixel Square.ttf') format('truetype'); }
        @font-face { font-family: 'Kenney Rocket'; src: url('fonts/Kenney Rocket.ttf') format('truetype'); }
        @font-face { font-family: 'Kenney Rocket Square'; src: url('fonts/Kenney Rocket Square.ttf') format('truetype'); }
        @font-face { font-family: 'Kunika'; src: url('fonts/Kunika.otf') format('opentype'); }
        @font-face { font-family: 'NIKEA'; src: url('fonts/NIKEA.otf') format('opentype'); }
        @font-face { font-family: 'RC Rocket'; src: url('fonts/RcRocketRegular.otf') format('opentype'); }
        @font-face { font-family: 'SinkinSans'; src: url('fonts/SinkinSans-100Thin.otf') format('opentype'); font-weight: 100; }
        @font-face { font-family: 'SinkinSans'; src: url('fonts/SinkinSans-100ThinItalic.otf') format('opentype'); font-weight: 100; font-style: italic; }
        @font-face { font-family: 'SinkinSans'; src: url('fonts/SinkinSans-200XLight.otf') format('opentype'); font-weight: 200; }
        @font-face { font-family: 'SinkinSans'; src: url('fonts/SinkinSans-200XLightItalic.otf') format('opentype'); font-weight: 200; font-style: italic; }
        @font-face { font-family: 'SinkinSans'; src: url('fonts/SinkinSans-300Light.otf') format('opentype'); font-weight: 300; }
        @font-face { font-family: 'SinkinSans'; src: url('fonts/SinkinSans-300LightItalic.otf') format('opentype'); font-weight: 300; font-style: italic; }
        @font-face { font-family: 'SinkinSans'; src: url('fonts/SinkinSans-400Regular.otf') format('opentype'); font-weight: 400; }
        @font-face { font-family: 'SinkinSans'; src: url('fonts/SinkinSans-400Italic.otf') format('opentype'); font-weight: 400; font-style: italic; }
        @font-face { font-family: 'SinkinSans'; src: url('fonts/SinkinSans-500Medium.otf') format('opentype'); font-weight: 500; }
        @font-face { font-family: 'SinkinSans'; src: url('fonts/SinkinSans-500MediumItalic.otf') format('opentype'); font-weight: 500; font-style: italic; }
        @font-face { font-family: 'SinkinSans'; src: url('fonts/SinkinSans-600SemiBold.otf') format('opentype'); font-weight: 600; }
        @font-face { font-family: 'SinkinSans'; src: url('fonts/SinkinSans-600SemiBoldItali.otf') format('opentype'); font-weight: 600; font-style: italic; }
        @font-face { font-family: 'SinkinSans'; src: url('fonts/SinkinSans-700Bold.otf') format('opentype'); font-weight: 700; }
        @font-face { font-family: 'SinkinSans'; src: url('fonts/SinkinSans-700BoldItalic.otf') format('opentype'); font-weight: 700; font-style: italic; }
        @font-face { font-family: 'SinkinSans'; src: url('fonts/SinkinSans-800Black.otf') format('opentype'); font-weight: 800; }
        @font-face { font-family: 'SinkinSans'; src: url('fonts/SinkinSans-800BlackItalic.otf') format('opentype'); font-weight: 800; font-style: italic; }
        @font-face { font-family: 'SinkinSans'; src: url('fonts/SinkinSans-900XBlack.otf') format('opentype'); font-weight: 900; }
        @font-face { font-family: 'SinkinSans'; src: url('fonts/SinkinSans-900XBlackItalic.otf') format('opentype'); font-weight: 900; font-style: italic; }
        @font-face { font-family: 'Tabuti'; src: url('fonts/Tabuti.otf') format('opentype'); }
        @font-face { font-family: 'Teko Medium'; src: url('fonts/Teko-Medium-BF64489c9b77919.ttf') format('truetype'); }
        
        /* Page-specific styles */
        .header {
            text-align: center;
            margin-bottom: 20px;
        }

        .title {
            font-size: 2.5rem;
            font-weight: 700;
            background: var(--primary);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin: 0 0 8px 0;
            letter-spacing: -0.02em;
        }

        .subtitle {
            font-size: 1.1rem;
            color: var(--text-secondary);
            font-weight: 400;
            margin: 0;
        }

        .input-section {
            width: 100%;
            max-width: 1000px;
            padding: 40px;
            background: var(--surface);
            border-radius: var(--radius);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
        }

        .input-section h3 {
            color: var(--text-primary);
            margin-top: 0;
            margin-bottom: 20px;
            font-weight: 600;
        }

        .text-input-group {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .text-input {
            padding: 16px 20px;
            font-size: 18px;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--surface);
            color: var(--text-primary);
            font-family: inherit;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            resize: vertical;
            min-height: 60px;
        }

        .text-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
            background: rgba(255, 255, 255, 0.08);
        }

        .text-input:hover {
            border-color: rgba(255, 255, 255, 0.2);
            background: var(--surface-hover);
        }

        .canvas-container {
            position: relative;
            border-radius: var(--radius);
            overflow: hidden;
            box-shadow: var(--shadow);
            background: var(--surface);
            padding: 20px;
            backdrop-filter: blur(20px);
            border: 1px solid var(--border);
            width: 100%;
            max-width: 1000px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #canvas {
            background: #00FF00;
            border-radius: 12px;
            max-width: 100%;
            width: 100%;
            height: auto;
            aspect-ratio: 16/9; /* Fixed 16:9 aspect ratio */
            display: block;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            image-rendering: auto;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            text-rendering: optimizeLegibility;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 24px;
            width: 100%;
            max-width: 1000px;
            padding: 40px;
            background: var(--surface);
            border-radius: var(--radius);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
        }

        .controls h3 {
            color: var(--text-primary);
            margin-top: 0;
            margin-bottom: 20px;
            font-weight: 600;
            grid-column: 1 / -1;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 12px;
            align-items: flex-start;
        }

        .control-group label {
            color: var(--text-primary);
            font-weight: 600;
            font-size: 14px;
            letter-spacing: 0.01em;
            margin-bottom: 4px;
            width: 100%;
        }

        input[type="color"] {
            width: 60px;
            height: 48px;
            padding: 4px;
            border: 2px solid var(--border);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            overflow: hidden;
            align-self: flex-start;
        }

        input[type="color"]:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
        }

        select {
            padding: 12px 16px;
            font-size: 14px;
            border: 1px solid var(--border);
            border-radius: 12px;
            background: var(--surface);
            color: var(--text-primary);
            font-family: inherit;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%23a0a0a0' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
            background-position: right 12px center;
            background-repeat: no-repeat;
            background-size: 16px;
            padding-right: 40px;
            width: 100%;
        }

        select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
            background: rgba(255, 255, 255, 0.08);
        }

        select:hover {
            border-color: rgba(255, 255, 255, 0.2);
            background: var(--surface-hover);
        }

        select option {
            background: #2a2a2a !important;
            color: #ffffff !important;
            padding: 8px 12px;
            border: none;
        }

        select option:hover {
            background: #3a3a3a !important;
            color: #ffffff !important;
        }

        select option:checked,
        select option:focus {
            background: #667eea !important;
            color: white !important;
        }

        /* Ensure dropdown list background is dark */
        select:focus option {
            background: #2a2a2a !important;
            color: #ffffff !important;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: var(--surface-hover);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            margin: 8px 0;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--secondary);
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--secondary);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .control-group span {
            color: var(--text-secondary);
            font-weight: 500;
            font-size: 14px;
            margin-top: 4px;
            align-self: flex-start;
        }

        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #667eea;
            cursor: pointer;
        }

        .export-button {
            padding: 18px 36px;
            font-size: 16px;
            font-weight: 600;
            border: none;
            border-radius: 12px;
            background: var(--secondary);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 16px rgba(245, 87, 108, 0.3);
            font-family: inherit;
            letter-spacing: 0.01em;
            position: relative;
            overflow: hidden;
            grid-column: 1 / -1;
            margin-top: 20px;
            justify-self: center;
            min-width: 200px;
        }

        .export-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(245, 87, 108, 0.4);
        }

        .export-button:active {
            transform: translateY(0);
        }

        .export-button:disabled {
            background: linear-gradient(135deg, #4a4a4a 0%, #2a2a2a 100%);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .export-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .export-button:hover::before {
            left: 100%;
        }

        .export-status {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 12px 20px;
            background: var(--surface);
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            margin-top: 20px;
            border: 1px solid var(--border);
            color: var(--text-primary);
            grid-column: 1 / -1;
            justify-self: center;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--success);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .container > * {
            animation: fadeIn 0.6s ease forwards;
        }

        .container > *:nth-child(2) { animation-delay: 0.1s; }
        .container > *:nth-child(3) { animation-delay: 0.2s; }
        .container > *:nth-child(4) { animation-delay: 0.3s; }

        .line-controls {
            grid-column: 1 / -1;
            margin-top: 20px;
        }

        .line-control-item {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 12px;
            margin-bottom: 12px;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .line-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            background: var(--surface-hover);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .line-header:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .line-preview {
            font-weight: 600;
            color: var(--text-primary);
            flex: 1;
        }

        .expand-icon {
            transition: transform 0.3s ease;
            color: var(--text-secondary);
        }

        .line-controls-content {
            padding: 20px;
            display: none;
            background: rgba(255, 255, 255, 0.02);
        }

        .line-controls-content.expanded {
            display: block;
        }

        .line-control-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 24px;
            margin-bottom: 20px;
            align-items: start;
        }

        .line-control-group:last-child {
            margin-bottom: 0;
        }

        /* Per-line control specific styling */
        .line-controls-content .control-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: flex-start;
            height: 100%;
            min-height: 80px;
        }

        .line-controls-content .control-group label {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 4px;
            width: 100%;
            height: 20px;
            display: flex;
            align-items: center;
        }

        .line-controls-content input[type="range"] {
            width: 100%;
            margin: 6px 0;
        }

        .line-controls-content input[type="color"] {
            width: 50px;
            height: 40px;
            align-self: flex-start;
            margin-top: 4px;
        }

        .line-controls-content select {
            width: 100%;
            padding: 10px 14px;
            font-size: 13px;
            height: 44px;
        }

        .line-controls-content span {
            font-size: 13px;
            color: var(--text-secondary);
            margin-top: 4px;
            height: 18px;
            display: flex;
            align-items: center;
        }

        .line-controls-content .font-style-controls {
            margin-top: 4px;
        }

        .color-controls {
            display: flex;
            gap: 16px;
            align-items: center;
            margin-top: 4px;
        }

        .color-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
        }

        .color-label {
            font-size: 11px;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .font-weight-control {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .font-style-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 4px;
        }

        .style-button {
            padding: 10px 16px;
            border: 1px solid var(--border);
            border-radius: 8px;
            background: var(--surface);
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 13px;
            font-weight: 500;
            min-width: 60px;
            text-align: center;
        }

        .style-button:hover {
            background: var(--surface-hover);
            border-color: #667eea;
        }

        .style-button.active {
            background: #667eea;
            border-color: #667eea;
            color: white;
        }

        @media (max-width: 768px) {
            .title {
                font-size: 2rem;
            }
            
            .input-section, .controls, .canvas-container {
                max-width: 100%;
                padding: 24px;
                margin: 0 16px;
            }
            
            .controls {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .export-button {
                width: 100%;
                min-width: auto;
            }
            
            .line-control-group {
                grid-template-columns: 1fr;
                gap: 16px;
            }
            
            .line-controls-content {
                padding: 16px;
            }
            
            .line-controls-content .control-group {
                gap: 6px;
            }
            
            .font-style-controls {
                justify-content: center;
            }
            
            .control-group {
                gap: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="title">📝 Text on Green Screen</h1>
            <p class="subtitle">Create viral text animations with professional green screen export</p>
        </div>
        
        <div class="input-section">
            <h3>✏️ Enter Your Text (One Line Per Animation)</h3>
            <div class="text-input-group">
                <textarea 
                    id="textInput" 
                    class="text-input" 
                    placeholder="Type your text here, one line per animation...&#10;Each line will fade in sequentially&#10;Video duration depends on number of lines&#10;&#10;Example:&#10;Line 1&#10;Line 2&#10;Line 3"
                    rows="8"
                >Welcome Home
This Works
And That
Each Line
Smooth Animation</textarea>
            </div>
        </div>

        <div class="canvas-container">
            <canvas id="canvas" width="3840" height="2160"></canvas>
        </div>

        <div class="controls">
            <h3>🎨 Text Styling</h3>
            <div class="control-group">
                <label for="fontStyle">Font Family (Global Default)</label>
                <select id="fontStyle">
                    <option value="Inter">Inter (Modern)</option>
                    <option value="Bebas Neue">Bebas Neue (Bold Titles)</option>
                    <option value="Helvetica">Helvetica (Clean)</option>
                    <option value="Futura">Futura (Geometric)</option>
                    <option value="Arial">Arial (Reliable)</option>
                    <option value="Oswald">Oswald (Condensed)</option>
                    <option value="Gotham">Gotham (Versatile)</option>
                    <option value="Montserrat">Montserrat (Friendly)</option>
                    <option value="Raleway">Raleway (Sleek)</option>
                    <option value="Anton">Anton (Heavy)</option>
                    <option value="Roboto">Roboto (Modern)</option>
                    <option value="Lato">Lato (Professional)</option>
                    <option value="Playfair Display">Playfair Display (Elegant)</option>
                    <option value="Eurostile">Eurostile (Futuristic)</option>
                    <option value="Impact">Impact (Bold)</option>
                    <option value="Lucida Grande">Lucida Grande (Clear)</option>
                    <option value="Tahoma">Tahoma (Narrow)</option>
                    <option value="Cinzel">Cinzel (Classical)</option>
                    <option value="League Gothic">League Gothic (Vintage)</option>
                    <option value="Michroma">Michroma (Futuristic)</option>
                    <option value="Prompt">Prompt (Modern Sans)</option>
                    <!-- Local Custom Fonts -->
                    <option value="Grammastile">Grammastile (Display)</option>
                    <option value="Atalanta">Atalanta (Elegant)</option>
                    <option value="De Valencia">De Valencia (Decorative)</option>
                    <option value="Ducados">Ducados (Vintage)</option>
                    <option value="Evolventa">Evolventa (Modern)</option>
                    <option value="FFF Nepsza">FFF Nepsza (Bold)</option>
                    <option value="Grotesk 812">Grotesk 812 (Condensed)</option>
                    <option value="Humane">Humane (Humanist)</option>
                    <option value="Kenney Blocks">Kenney Blocks (Gaming)</option>
                    <option value="Kenney Future">Kenney Future (Sci-Fi)</option>
                    <option value="Kenney Future Narrow">Kenney Future Narrow (Sci-Fi)</option>
                    <option value="Kenney High">Kenney High (Gaming)</option>
                    <option value="Kenney High Square">Kenney High Square (Gaming)</option>
                    <option value="Kenney Mini">Kenney Mini (Compact)</option>
                    <option value="Kenney Mini Square">Kenney Mini Square (Compact)</option>
                    <option value="Kenney Pixel">Kenney Pixel (Retro)</option>
                    <option value="Kenney Pixel Square">Kenney Pixel Square (Retro)</option>
                    <option value="Kenney Rocket">Kenney Rocket (Space)</option>
                    <option value="Kenney Rocket Square">Kenney Rocket Square (Space)</option>
                    <option value="Kunika">Kunika (Stylish)</option>
                    <option value="NIKEA">NIKEA (Bold)</option>
                    <option value="RC Rocket">RC Rocket (Tech)</option>
                    <option value="SinkinSans">SinkinSans (Professional)</option>
                    <option value="Tabuti">Tabuti (Unique)</option>
                    <option value="Teko Medium">Teko Medium (Condensed)</option>
                    <option value="Morganite">Morganite (Urban)</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="textColor">Text Color</label>
                <input type="color" id="textColor" value="#ffffff">
            </div>
            
            <div class="control-group">
                <label for="globalFontWeight">Font Weight (Global)</label>
                <input type="range" id="globalFontWeight" min="100" max="900" step="100" value="700">
                <span id="globalFontWeightValue">700</span>
            </div>
            
            <div class="control-group">
                <label for="globalFontStyle">Font Style (Global)</label>
                <select id="globalFontStyle">
                    <option value="normal">Normal</option>
                    <option value="italic">Italic</option>
                    <option value="oblique">Oblique</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="globalStrokeWidth">Stroke Width (Global)</label>
                <input type="range" id="globalStrokeWidth" min="0" max="10" step="0.5" value="0">
                <span id="globalStrokeWidthValue">0px</span>
            </div>
            
            <div class="control-group">
                <label for="globalStrokeColor">Stroke Color (Global)</label>
                <input type="color" id="globalStrokeColor" value="#000000">
            </div>
            
            
            <div class="control-group">
                <label for="textAlign">Text Alignment</label>
                <select id="textAlign">
                    <option value="center" selected>Center</option>
                    <option value="left">Left</option>
                    <option value="right">Right</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="globalAnimation">Intro Animation (Global)</label>
                <select id="globalAnimation">
                    <option value="fade-in" selected>Fade In</option>
                    <option value="slide-left">Slide from Left</option>
                    <option value="slide-right">Slide from Right</option>
                    <option value="slide-up">Slide from Bottom</option>
                    <option value="slide-down">Slide from Top</option>
                    <option value="pop-in">Pop In</option>
                    <option value="bounce-in">Bounce In</option>
                    <option value="zoom-in">Zoom In</option>
                    <option value="flip-in">Flip In</option>
                    <option value="typewriter">Typewriter</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="globalAnimationSpeed">Animation Speed (Global)</label>
                <input type="range" id="globalAnimationSpeed" min="0.2" max="3.0" step="0.1" value="1.0">
                <span id="globalAnimationSpeedValue">1.0x</span>
            </div>
            
            <div class="control-group" style="display: none;">
                <label for="animationSpeed">Animation Speed</label>
                <input type="range" id="animationSpeed" min="0.5" max="5" step="0.1" value="3">
                <span id="speedValue">3.0x</span>
            </div>
            
            
            <div class="control-group">
                <label for="lineHeight">Line Height</label>
                <input type="range" id="lineHeight" min="0.5" max="1.3" step="0.1" value="1">
            </div>
            
            <div class="line-controls">
                <h3>🎯 Per-Line Controls</h3>
                <div id="lineControlsContainer">
                    <!-- Per-line controls will be dynamically generated here -->
                </div>
            </div>
            
            <button id="exportBtn" class="export-button">
                <span>🎬 Export as MP4</span>
            </button>
            <div id="exportStatus" class="export-status" style="display: none;">
                <div class="status-dot"></div>
                <span id="exportStatusText">Ready to export</span>
            </div>
        </div>
    </div>

    <script>
        class TextGreenScreen {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.textInput = document.getElementById('textInput');
                this.exportBtn = document.getElementById('exportBtn');
                this.exportStatus = document.getElementById('exportStatus');
                this.exportStatusText = document.getElementById('exportStatusText');
                
                // Control elements
                this.fontStyleSelect = document.getElementById('fontStyle');
                this.textColorInput = document.getElementById('textColor');
                this.textAlignSelect = document.getElementById('textAlign');
                this.globalAnimationSelect = document.getElementById('globalAnimation');
                this.globalAnimationSpeed = document.getElementById('globalAnimationSpeed');
                this.globalAnimationSpeedValue = document.getElementById('globalAnimationSpeedValue');
                
                // Global font styling controls
                this.globalFontWeight = document.getElementById('globalFontWeight');
                this.globalFontWeightValue = document.getElementById('globalFontWeightValue');
                this.globalFontStyle = document.getElementById('globalFontStyle');
                this.globalStrokeWidth = document.getElementById('globalStrokeWidth');
                this.globalStrokeWidthValue = document.getElementById('globalStrokeWidthValue');
                this.globalStrokeColor = document.getElementById('globalStrokeColor');
                
                // Debug: Check if elements exist
                if (!this.globalStrokeWidthValue) {
                    console.error('globalStrokeWidthValue element not found');
                }
                if (!this.globalFontWeightValue) {
                    console.error('globalFontWeightValue element not found');
                }
                this.animationSpeedSlider = document.getElementById('animationSpeed');
                this.speedValueSpan = document.getElementById('speedValue');
                this.lineHeightSlider = document.getElementById('lineHeight');
                this.lineControlsContainer = document.getElementById('lineControlsContainer');
                
                // Animation state
                this.isExporting = false;
                this.animationId = null;
                this.animationTime = 0;
                this.lines = [];
                this.lineProperties = []; // Array to store per-line properties
                this.lineDuration = 1.5; // seconds per line
                this.fadeInDuration = 0.5; // seconds for fade in effect
                this.endDelay = 2.0; // extra seconds at the end to show all lines
                this.animationSpeed = 3.0; // speed multiplier
                this.lineHeightMultiplier = 1.0; // line height multiplier
                this.loopDuration = 0;
                this.shouldLoop = true;
                
                this.init();
            }

            init() {
                this.setupEventListeners();
                this.generateLineControls();
                setTimeout(() => {
                    this.setupHighDPICanvas();
                    this.calculateLoopDuration();
                this.startAnimation();
                }, 100);
            }

            setupHighDPICanvas() {
                const devicePixelRatio = window.devicePixelRatio || 1;
                const container = this.canvas.parentElement;
                const containerWidth = container.clientWidth - 40; // Account for 20px padding on left/right sides
                
                // Fixed 16:9 aspect ratio for preview canvas
                const containerHeight = containerWidth * (9/16); // Always 16:9
                
                // Set the actual size in memory (scaled to account for extra pixel density)
                this.canvas.width = containerWidth * devicePixelRatio;
                this.canvas.height = containerHeight * devicePixelRatio;
                
                // Scale the drawing context so everything will work at the higher ratio
                this.ctx.scale(devicePixelRatio, devicePixelRatio);
                
                // Set the display size (CSS pixels)
                this.canvas.style.width = containerWidth + 'px';
                this.canvas.style.height = containerHeight + 'px';
            }

            startAnimation() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
                this.animate();
            }

            stopAnimation() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
            }

            animate() {
                this.animationTime += (1/60) * this.animationSpeed;
                if (this.shouldLoop && this.loopDuration > 0 && this.animationTime >= this.loopDuration) {
                    this.animationTime = 0;
                }
                this.drawText();
                this.animationId = requestAnimationFrame(() => this.animate());
            }

            setupEventListeners() {
                this.textInput.addEventListener('input', () => {
                    this.generateLineControls();
                    this.restartAnimation();
                });
                this.fontStyleSelect.addEventListener('change', () => {
                    // Update all existing line properties with the new global font
                    this.lineProperties.forEach(lineProp => {
                        lineProp.fontFamily = this.fontStyleSelect.value;
                    });
                    
                    // Update all font family dropdowns in the UI to reflect the global change
                    const fontSelects = this.lineControlsContainer.querySelectorAll('select[onchange*="fontFamily"]');
                    fontSelects.forEach(select => {
                        select.value = this.fontStyleSelect.value;
                    });
                    
                    this.restartAnimation();
                });
                this.textColorInput.addEventListener('change', () => {
                    // Update all existing line properties with the new global color
                    this.lineProperties.forEach(lineProp => {
                        lineProp.color = this.textColorInput.value;
                    });
                    this.restartAnimation();
                });
                
                // Global font weight control
                if (this.globalFontWeight) {
                    this.globalFontWeight.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    console.log('Font weight changed to:', value);
                    if (this.globalFontWeightValue) {
                        this.globalFontWeightValue.textContent = value;
                    } else {
                        console.error('globalFontWeightValue is null');
                    }
                    this.lineProperties.forEach(lineProp => {
                        lineProp.fontWeight = value;
                    });
                    this.restartAnimation();
                    });
                } else {
                    console.error('globalFontWeight element not found');
                }
                
                // Global font style control
                this.globalFontStyle.addEventListener('change', () => {
                    this.lineProperties.forEach(lineProp => {
                        lineProp.fontStyle = this.globalFontStyle.value;
                    });
                    this.restartAnimation();
                });
                
                // Global stroke width control
                if (this.globalStrokeWidth) {
                    this.globalStrokeWidth.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    console.log('Stroke width changed to:', value);
                    if (this.globalStrokeWidthValue) {
                        this.globalStrokeWidthValue.textContent = value + 'px';
                    } else {
                        console.error('globalStrokeWidthValue is null');
                    }
                    this.lineProperties.forEach(lineProp => {
                        lineProp.strokeWidth = value;
                    });
                    this.restartAnimation();
                    });
                } else {
                    console.error('globalStrokeWidth element not found');
                }
                
                // Global stroke color control
                this.globalStrokeColor.addEventListener('change', () => {
                    this.lineProperties.forEach(lineProp => {
                        lineProp.strokeColor = this.globalStrokeColor.value;
                    });
                    this.restartAnimation();
                });
                
                this.textAlignSelect.addEventListener('change', () => {
                    // Update all existing line properties with the new global alignment
                    this.lineProperties.forEach(lineProp => {
                        lineProp.textAlign = this.textAlignSelect.value;
                    });
                    this.restartAnimation();
                });
                
                this.globalAnimationSelect.addEventListener('change', () => {
                    // Update all existing line properties with the new global animation
                    this.lineProperties.forEach(lineProp => {
                        lineProp.animationType = this.globalAnimationSelect.value;
                    });
                    
                    // Update all animation dropdowns in the UI to reflect the global change
                    const animationSelects = this.lineControlsContainer.querySelectorAll('select[onchange*="animationType"]');
                    animationSelects.forEach(select => {
                        select.value = this.globalAnimationSelect.value;
                    });
                    
                    this.restartAnimation();
                });
                
                this.globalAnimationSpeed.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    this.globalAnimationSpeedValue.textContent = value.toFixed(1) + 'x';
                    
                    // Update all existing line properties with the new global animation speed
                    this.lineProperties.forEach(lineProp => {
                        lineProp.animationSpeed = value;
                    });
                    
                    // Update all animation speed sliders in the UI to reflect the global change
                    const animationSpeedInputs = this.lineControlsContainer.querySelectorAll('input[onchange*="animationSpeed"]');
                    animationSpeedInputs.forEach(input => {
                        input.value = value;
                        const index = input.getAttribute('onchange').match(/\d+/)[0];
                        const speedSpan = document.getElementById(`animationSpeedValue_${index}`);
                        if (speedSpan) {
                            speedSpan.textContent = value.toFixed(1) + 'x';
                        }
                    });
                    
                    this.restartAnimation();
                });
                this.exportBtn.addEventListener('click', () => this.startExport());
                
                // Animation speed control (commented out)
                // this.animationSpeedSlider.addEventListener('input', (e) => {
                //     this.animationSpeed = parseFloat(e.target.value);
                //     this.speedValueSpan.textContent = this.animationSpeed.toFixed(1) + 'x';
                //     this.restartAnimation();
                // });
                
                
                // Line height control
                this.lineHeightSlider.addEventListener('input', (e) => {
                    this.lineHeightMultiplier = parseFloat(e.target.value);
                    this.restartAnimation();
                });
                
                // Handle window resize
                window.addEventListener('resize', () => {
                    this.setupHighDPICanvas();
                });
            }

            calculateLoopDuration() {
                const text = this.textInput.value.trim();
                const currentLines = text.split('\n').filter(line => line.trim() !== '');
                
                if (currentLines.length === 0) {
                    this.loopDuration = 0;
                    return;
                }
                
                // Calculate cumulative time for sequential animations
                let cumulativeTime = 0;
                currentLines.forEach((line, index) => {
                    const lineProps = this.lineProperties[index] || this.getDefaultLineProperties();
                    const animationDuration = this.fadeInDuration / (lineProps.speed * (lineProps.animationSpeed || 1.0));
                    const lineDelay = this.lineDuration / lineProps.speed;
                    
                    // Each line starts after the previous line's animation completes
                    if (index === 0) {
                        cumulativeTime = animationDuration;
                    } else {
                        cumulativeTime += lineDelay + animationDuration;
                    }
                });
                
                // Add end delay
                this.loopDuration = cumulativeTime + this.endDelay;
            }

            getLineStartTime(lineIndex) {
                const text = this.textInput.value.trim();
                const lines = text.split('\n').filter(line => line.trim() !== '');
                
                if (lineIndex === 0) {
                    return 0; // First line starts immediately
                }
                
                // Calculate cumulative time for all previous lines
                let cumulativeTime = 0;
                for (let i = 0; i < lineIndex; i++) {
                    const lineProps = this.lineProperties[i] || this.getDefaultLineProperties();
                    const animationDuration = this.fadeInDuration / (lineProps.speed * (lineProps.animationSpeed || 1.0));
                    const lineDelay = this.lineDuration / lineProps.speed;
                    
                    if (i === 0) {
                        cumulativeTime = animationDuration + lineDelay;
                    } else {
                        cumulativeTime += animationDuration + lineDelay;
                    }
                }
                
                return cumulativeTime;
            }

            restartAnimation() {
                this.calculateLoopDuration();
                this.animationTime = 0; // Reset to start
                this.startAnimation();
            }


            getDefaultLineProperties() {
                return {
                    speed: 1.0,
                    fontFamily: this.fontStyleSelect.value,
                    fontWeight: parseInt(this.globalFontWeight.value),
                    fontStyle: this.globalFontStyle.value,
                    color: this.textColorInput.value,
                    strokeWidth: parseFloat(this.globalStrokeWidth.value),
                    strokeColor: this.globalStrokeColor.value,
                    textAlign: this.textAlignSelect.value,
                    animationType: this.globalAnimationSelect.value,
                    animationSpeed: parseFloat(this.globalAnimationSpeed.value)
                };
            }

            getFontSize() {
                const text = this.textInput.value.trim();
                const lines = text.split('\n').filter(line => line.trim() !== '');
                const lineCount = Math.max(1, lines.length);
                
                const canvasWidth = this.canvas.width / (window.devicePixelRatio || 1);
                const canvasHeight = this.canvas.height / (window.devicePixelRatio || 1);
                const baseFontSize = canvasWidth * 0.15; // Increased base font size for better quality
                
                // Calculate optimal font size based on vertical space
                const availableHeight = canvasHeight * 0.8; // Use 80% of canvas height
                const lineSpacing = this.lineHeightMultiplier;
                const optimalFontSize = (availableHeight / lineCount) / lineSpacing;
                
                let fontSize;
                if (lineCount <= 1) {
                    fontSize = baseFontSize;
                } else if (lineCount <= 3) {
                    fontSize = Math.min(baseFontSize * 0.9, optimalFontSize);
                } else if (lineCount <= 5) {
                    fontSize = Math.min(baseFontSize * 0.75, optimalFontSize);
                } else if (lineCount <= 10) {
                    fontSize = Math.min(baseFontSize * 0.6, optimalFontSize);
                } else if (lineCount <= 15) {
                    fontSize = Math.min(baseFontSize * 0.5, optimalFontSize);
                } else if (lineCount <= 20) {
                    fontSize = Math.min(baseFontSize * 0.45, optimalFontSize);
                } else {
                    fontSize = Math.min(baseFontSize * 0.4, optimalFontSize);
                }
                
                fontSize = fontSize * this.lineHeightMultiplier;
                
                // Now check horizontal constraints for each line and adjust if needed
                const availableWidth = canvasWidth * 0.9; // Use 90% of canvas width for safety margin
                let maxRequiredFontSize = fontSize;
                
                lines.forEach((line, index) => {
                    const lineProps = this.lineProperties[index] || this.getDefaultLineProperties();
                    
                    // Create a temporary canvas context to measure text width
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.font = `${lineProps.fontStyle} ${lineProps.fontWeight} ${fontSize}px ${lineProps.fontFamily}`;
                    
                    const textWidth = tempCtx.measureText(line).width;
                    
                    if (textWidth > availableWidth) {
                        // Calculate the maximum font size that would fit this line
                        const scaleFactor = availableWidth / textWidth;
                        const adjustedFontSize = fontSize * scaleFactor;
                        maxRequiredFontSize = Math.min(maxRequiredFontSize, adjustedFontSize);
                    }
                });
                
                fontSize = maxRequiredFontSize;
                
                const minFontSize = 16;
                fontSize = Math.max(minFontSize, fontSize);
                return fontSize;
            }

            generateLineControls() {
                const text = this.textInput.value.trim();
                const currentLines = text.split('\n').filter(line => line.trim() !== '');
                
                // Update line properties array
                while (this.lineProperties.length < currentLines.length) {
                    this.lineProperties.push(this.getDefaultLineProperties());
                }
                this.lineProperties = this.lineProperties.slice(0, currentLines.length);
                
                // Generate HTML for line controls
                this.lineControlsContainer.innerHTML = '';
                
                currentLines.forEach((line, index) => {
                    const lineControl = this.createLineControl(line, index);
                    this.lineControlsContainer.appendChild(lineControl);
                });
                
                // Resize canvas based on new line count
                this.setupHighDPICanvas();
                
                // Restart animation when line controls are generated
                this.restartAnimation();
            }

            createLineControl(lineText, index) {
                const lineProps = this.lineProperties[index] || this.getDefaultLineProperties();
                const div = document.createElement('div');
                div.className = 'line-control-item';
                div.innerHTML = `
                    <div class="line-header" onclick="this.nextElementSibling.classList.toggle('expanded'); this.querySelector('.expand-icon').style.transform = this.nextElementSibling.classList.contains('expanded') ? 'rotate(180deg)' : 'rotate(0deg)'">
                        <span class="line-preview">Line ${index + 1}: "${lineText}"</span>
                        <span class="expand-icon">▼</span>
                    </div>
                    <div class="line-controls-content">
                        <div class="line-control-group">
                            <div class="control-group">
                                <label>Font Family</label>
                                <select onchange="textGreenScreen.updateLineProperty(${index}, 'fontFamily', this.value)">
                                    <option value="Inter" ${lineProps.fontFamily === 'Inter' ? 'selected' : ''}>Inter</option>
                                    <option value="Bebas Neue" ${lineProps.fontFamily === 'Bebas Neue' ? 'selected' : ''}>Bebas Neue</option>
                                    <option value="Helvetica" ${lineProps.fontFamily === 'Helvetica' ? 'selected' : ''}>Helvetica</option>
                                    <option value="Futura" ${lineProps.fontFamily === 'Futura' ? 'selected' : ''}>Futura</option>
                                    <option value="Arial" ${lineProps.fontFamily === 'Arial' ? 'selected' : ''}>Arial</option>
                                    <option value="Oswald" ${lineProps.fontFamily === 'Oswald' ? 'selected' : ''}>Oswald</option>
                                    <option value="Gotham" ${lineProps.fontFamily === 'Gotham' ? 'selected' : ''}>Gotham</option>
                                    <option value="Montserrat" ${lineProps.fontFamily === 'Montserrat' ? 'selected' : ''}>Montserrat</option>
                                    <option value="Raleway" ${lineProps.fontFamily === 'Raleway' ? 'selected' : ''}>Raleway</option>
                                    <option value="Anton" ${lineProps.fontFamily === 'Anton' ? 'selected' : ''}>Anton</option>
                                    <option value="Roboto" ${lineProps.fontFamily === 'Roboto' ? 'selected' : ''}>Roboto</option>
                                    <option value="Lato" ${lineProps.fontFamily === 'Lato' ? 'selected' : ''}>Lato</option>
                                    <option value="Playfair Display" ${lineProps.fontFamily === 'Playfair Display' ? 'selected' : ''}>Playfair Display</option>
                                    <option value="Eurostile" ${lineProps.fontFamily === 'Eurostile' ? 'selected' : ''}>Eurostile</option>
                                    <option value="Impact" ${lineProps.fontFamily === 'Impact' ? 'selected' : ''}>Impact</option>
                                    <option value="Lucida Grande" ${lineProps.fontFamily === 'Lucida Grande' ? 'selected' : ''}>Lucida Grande</option>
                                    <option value="Tahoma" ${lineProps.fontFamily === 'Tahoma' ? 'selected' : ''}>Tahoma</option>
                                    <option value="Cinzel" ${lineProps.fontFamily === 'Cinzel' ? 'selected' : ''}>Cinzel</option>
                                    <option value="League Gothic" ${lineProps.fontFamily === 'League Gothic' ? 'selected' : ''}>League Gothic</option>
                                    <option value="Michroma" ${lineProps.fontFamily === 'Michroma' ? 'selected' : ''}>Michroma</option>
                                    <option value="Prompt" ${lineProps.fontFamily === 'Prompt' ? 'selected' : ''}>Prompt</option>
                                    <option value="Grammastile" ${lineProps.fontFamily === 'Grammastile' ? 'selected' : ''}>Grammastile</option>
                                    <option value="Atalanta" ${lineProps.fontFamily === 'Atalanta' ? 'selected' : ''}>Atalanta</option>
                                    <option value="De Valencia" ${lineProps.fontFamily === 'De Valencia' ? 'selected' : ''}>De Valencia</option>
                                    <option value="Ducados" ${lineProps.fontFamily === 'Ducados' ? 'selected' : ''}>Ducados</option>
                                    <option value="Evolventa" ${lineProps.fontFamily === 'Evolventa' ? 'selected' : ''}>Evolventa</option>
                                    <option value="FFF Nepsza" ${lineProps.fontFamily === 'FFF Nepsza' ? 'selected' : ''}>FFF Nepsza</option>
                                    <option value="Grotesk 812" ${lineProps.fontFamily === 'Grotesk 812' ? 'selected' : ''}>Grotesk 812</option>
                                    <option value="Humane" ${lineProps.fontFamily === 'Humane' ? 'selected' : ''}>Humane</option>
                                    <option value="Kenney Blocks" ${lineProps.fontFamily === 'Kenney Blocks' ? 'selected' : ''}>Kenney Blocks</option>
                                    <option value="Kenney Future" ${lineProps.fontFamily === 'Kenney Future' ? 'selected' : ''}>Kenney Future</option>
                                    <option value="Kenney Future Narrow" ${lineProps.fontFamily === 'Kenney Future Narrow' ? 'selected' : ''}>Kenney Future Narrow</option>
                                    <option value="Kenney High" ${lineProps.fontFamily === 'Kenney High' ? 'selected' : ''}>Kenney High</option>
                                    <option value="Kenney High Square" ${lineProps.fontFamily === 'Kenney High Square' ? 'selected' : ''}>Kenney High Square</option>
                                    <option value="Kenney Mini" ${lineProps.fontFamily === 'Kenney Mini' ? 'selected' : ''}>Kenney Mini</option>
                                    <option value="Kenney Mini Square" ${lineProps.fontFamily === 'Kenney Mini Square' ? 'selected' : ''}>Kenney Mini Square</option>
                                    <option value="Kenney Pixel" ${lineProps.fontFamily === 'Kenney Pixel' ? 'selected' : ''}>Kenney Pixel</option>
                                    <option value="Kenney Pixel Square" ${lineProps.fontFamily === 'Kenney Pixel Square' ? 'selected' : ''}>Kenney Pixel Square</option>
                                    <option value="Kenney Rocket" ${lineProps.fontFamily === 'Kenney Rocket' ? 'selected' : ''}>Kenney Rocket</option>
                                    <option value="Kenney Rocket Square" ${lineProps.fontFamily === 'Kenney Rocket Square' ? 'selected' : ''}>Kenney Rocket Square</option>
                                    <option value="Kunika" ${lineProps.fontFamily === 'Kunika' ? 'selected' : ''}>Kunika</option>
                                    <option value="NIKEA" ${lineProps.fontFamily === 'NIKEA' ? 'selected' : ''}>NIKEA</option>
                                    <option value="RC Rocket" ${lineProps.fontFamily === 'RC Rocket' ? 'selected' : ''}>RC Rocket</option>
                                    <option value="SinkinSans" ${lineProps.fontFamily === 'SinkinSans' ? 'selected' : ''}>SinkinSans</option>
                                    <option value="Tabuti" ${lineProps.fontFamily === 'Tabuti' ? 'selected' : ''}>Tabuti</option>
                                    <option value="Teko Medium" ${lineProps.fontFamily === 'Teko Medium' ? 'selected' : ''}>Teko Medium</option>
                                    <option value="Morganite" ${lineProps.fontFamily === 'Morganite' ? 'selected' : ''}>Morganite</option>
                                </select>
                            </div>
                            <div class="control-group">
                                <label>Font Weight</label>
                                <input type="range" min="100" max="900" step="100" value="${lineProps.fontWeight}" onchange="textGreenScreen.updateLineProperty(${index}, 'fontWeight', parseInt(this.value))">
                                <span id="fontWeightValue_${index}">${lineProps.fontWeight}</span>
                            </div>
                        </div>
                        <div class="line-control-group">
                            <div class="control-group">
                                <label>Font Style</label>
                                <div class="font-style-controls">
                                    <button class="style-button ${lineProps.fontStyle === 'normal' ? 'active' : ''}" onclick="textGreenScreen.toggleFontStyle(${index}, 'normal')">Normal</button>
                                    <button class="style-button ${lineProps.fontStyle === 'italic' ? 'active' : ''}" onclick="textGreenScreen.toggleFontStyle(${index}, 'italic')">Italic</button>
                                </div>
                            </div>
                            <div style="display: none;" class="control-group">
                                <label>Speed</label>
                                <input type="range" min="0.5" max="3" step="0.1" value="${lineProps.speed}" onchange="textGreenScreen.updateLineProperty(${index}, 'speed', parseFloat(this.value))">
                                <span id="speedValue_${index}">${lineProps.speed}x</span>
                            </div>
                                                        <div class="control-group">
                                <label>Colors</label>
                                <div class="color-controls">
                                    <div class="color-item">
                                        <span class="color-label">Text</span>
                                        <input type="color" value="${lineProps.color}" onchange="textGreenScreen.updateLineProperty(${index}, 'color', this.value)">
                                    </div>
                                    <div class="color-item">
                                        <span class="color-label">Stroke</span>
                                        <input type="color" value="${lineProps.strokeColor}" onchange="textGreenScreen.updateLineProperty(${index}, 'strokeColor', this.value)">
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="line-control-group">
                            <div class="control-group">
                                <label>Text Alignment</label>
                                <select onchange="textGreenScreen.updateLineProperty(${index}, 'textAlign', this.value)">
                                    <option value="center" ${lineProps.textAlign === 'center' ? 'selected' : ''}>Center</option>
                                    <option value="left" ${lineProps.textAlign === 'left' ? 'selected' : ''}>Left</option>
                                    <option value="right" ${lineProps.textAlign === 'right' ? 'selected' : ''}>Right</option>
                                </select>
                            </div>
                            <div class="control-group">
                                <label>Intro Animation</label>
                                <select onchange="textGreenScreen.updateLineProperty(${index}, 'animationType', this.value)">
                                    <option value="fade-in" ${lineProps.animationType === 'fade-in' ? 'selected' : ''}>Fade In</option>
                                    <option value="slide-left" ${lineProps.animationType === 'slide-left' ? 'selected' : ''}>Slide from Left</option>
                                    <option value="slide-right" ${lineProps.animationType === 'slide-right' ? 'selected' : ''}>Slide from Right</option>
                                    <option value="slide-up" ${lineProps.animationType === 'slide-up' ? 'selected' : ''}>Slide from Bottom</option>
                                    <option value="slide-down" ${lineProps.animationType === 'slide-down' ? 'selected' : ''}>Slide from Top</option>
                                    <option value="pop-in" ${lineProps.animationType === 'pop-in' ? 'selected' : ''}>Pop In</option>
                                    <option value="bounce-in" ${lineProps.animationType === 'bounce-in' ? 'selected' : ''}>Bounce In</option>
                                    <option value="zoom-in" ${lineProps.animationType === 'zoom-in' ? 'selected' : ''}>Zoom In</option>
                                    <option value="flip-in" ${lineProps.animationType === 'flip-in' ? 'selected' : ''}>Flip In</option>
                                    <option value="typewriter" ${lineProps.animationType === 'typewriter' ? 'selected' : ''}>Typewriter</option>
                                </select>
                            </div>
                            <div class="control-group">
                                <label>Animation Speed</label>
                                <input type="range" min="0.2" max="3.0" step="0.1" value="${lineProps.animationSpeed}" onchange="textGreenScreen.updateLineProperty(${index}, 'animationSpeed', parseFloat(this.value))">
                                <span id="animationSpeedValue_${index}">${lineProps.animationSpeed.toFixed(1)}x</span>
                            </div>
                            <div class="control-group">
                                <label>Stroke Width</label>
                                <input type="range" min="0" max="10" step="0.5" value="${lineProps.strokeWidth}" onchange="textGreenScreen.updateLineProperty(${index}, 'strokeWidth', parseFloat(this.value))">
                                <span id="strokeWidthValue_${index}">${lineProps.strokeWidth}px</span>
                            </div>
                        </div>
                    </div>
                `;
                return div;
            }

            updateLineProperty(lineIndex, property, value) {
                if (this.lineProperties[lineIndex]) {
                    this.lineProperties[lineIndex][property] = value;
                    
                    // Update the display text for the corresponding span
                    if (property === 'speed') {
                        const speedSpan = document.getElementById(`speedValue_${lineIndex}`);
                        if (speedSpan) {
                            speedSpan.textContent = value + 'x';
                        }
                    } else if (property === 'fontWeight') {
                        const fontWeightSpan = document.getElementById(`fontWeightValue_${lineIndex}`);
                        if (fontWeightSpan) {
                            fontWeightSpan.textContent = value;
                        }
                    } else if (property === 'strokeWidth') {
                        const strokeWidthSpan = document.getElementById(`strokeWidthValue_${lineIndex}`);
                        if (strokeWidthSpan) {
                            strokeWidthSpan.textContent = value + 'px';
                        }
                    } else if (property === 'animationSpeed') {
                        const animationSpeedSpan = document.getElementById(`animationSpeedValue_${lineIndex}`);
                        if (animationSpeedSpan) {
                            animationSpeedSpan.textContent = value.toFixed(1) + 'x';
                        }
                    }
                    
                    this.restartAnimation();
                }
            }

            toggleFontStyle(lineIndex, style) {
                console.log('toggleFontStyle called:', lineIndex, style);
                if (this.lineProperties[lineIndex]) {
                    this.lineProperties[lineIndex].fontStyle = style;
                    console.log('Updated line properties:', this.lineProperties[lineIndex]);
                    
                    // Update button states
                    const lineControlItem = this.lineControlsContainer.children[lineIndex];
                    if (lineControlItem) {
                        const buttons = lineControlItem.querySelectorAll('.style-button');
                        buttons.forEach(button => {
                            button.classList.remove('active');
                            if ((style === 'normal' && button.textContent === 'Normal') ||
                                (style === 'italic' && button.textContent === 'Italic')) {
                                button.classList.add('active');
                            }
                        });
                    }
                    
                    this.restartAnimation();
                }
            }

            getAnimationTransform(animationType, progress, canvasWidth, canvasHeight) {
                // progress is 0 to 1, where 0 is start of animation, 1 is fully visible
                const easeOutCubic = t => 1 - Math.pow(1 - t, 3);
                const easeOutBounce = t => {
                    const n1 = 7.5625;
                    const d1 = 2.75;
                    if (t < 1 / d1) {
                        return n1 * t * t;
                    } else if (t < 2 / d1) {
                        return n1 * (t -= 1.5 / d1) * t + 0.75;
                    } else if (t < 2.5 / d1) {
                        return n1 * (t -= 2.25 / d1) * t + 0.9375;
                    } else {
                        return n1 * (t -= 2.625 / d1) * t + 0.984375;
                    }
                };

                let alpha = progress;
                let translateX = 0;
                let translateY = 0;
                let scaleX = 1;
                let scaleY = 1;
                let rotation = 0;

                switch (animationType) {
                    case 'fade-in':
                        alpha = progress;
                        break;
                    
                    case 'slide-left':
                        alpha = progress;
                        translateX = (1 - easeOutCubic(progress)) * canvasWidth;
                        break;
                    
                    case 'slide-right':
                        alpha = progress;
                        translateX = -(1 - easeOutCubic(progress)) * canvasWidth;
                        break;
                    
                    case 'slide-up':
                        alpha = progress;
                        translateY = (1 - easeOutCubic(progress)) * canvasHeight * 0.5;
                        break;
                    
                    case 'slide-down':
                        alpha = progress;
                        translateY = -(1 - easeOutCubic(progress)) * canvasHeight * 0.5;
                        break;
                    
                    case 'pop-in':
                        alpha = progress;
                        const popScale = easeOutCubic(progress);
                        scaleX = scaleY = popScale;
                        break;
                    
                    case 'bounce-in':
                        alpha = Math.min(1, progress * 1.5);
                        const bounceScale = easeOutBounce(progress);
                        scaleX = scaleY = bounceScale;
                        break;
                    
                    case 'zoom-in':
                        alpha = progress;
                        const zoomScale = 0.3 + (easeOutCubic(progress) * 0.7);
                        scaleX = scaleY = zoomScale;
                        break;
                    
                    case 'flip-in':
                        alpha = progress;
                        rotation = (1 - easeOutCubic(progress)) * Math.PI;
                        scaleY = Math.cos(rotation * 0.5);
                        break;
                    
                    case 'typewriter':
                        alpha = 1;
                        // Typewriter effect will be handled differently
                        break;
                }

                return {
                    alpha,
                    translateX,
                    translateY,
                    scaleX,
                    scaleY,
                    rotation
                };
            }

            drawText() {
                this.ctx.imageSmoothingEnabled = true;
                this.ctx.imageSmoothingQuality = 'high';
                this.ctx.textRenderingOptimization = 'optimizeQuality';
                this.ctx.fontKerning = 'normal';
                this.ctx.fontVariantCaps = 'normal';
                
                this.ctx.fillStyle = '#00FF00';
                const canvasWidth = this.canvas.width / (window.devicePixelRatio || 1);
                const canvasHeight = this.canvas.height / (window.devicePixelRatio || 1);
                this.ctx.fillRect(0, 0, canvasWidth, canvasHeight);
                
                const text = this.textInput.value.trim();
                if (!text) {
                    // Show placeholder text
                    this.ctx.fillStyle = '#FFFFFF';
                    this.ctx.font = `bold ${this.getFontSize()}px ${this.fontStyleSelect.value}`;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText('Type your text above...', canvasWidth / 2, canvasHeight / 2);
                    return;
                }
                
                // Update lines array when text changes
                const currentLines = text.split('\n').filter(line => line.trim() !== '');
                if (JSON.stringify(currentLines) !== JSON.stringify(this.lines)) {
                    this.lines = currentLines;
                    this.animationTime = 0;
                }
                if (this.lines.length === 0) return;
                
                // Set text properties
                this.ctx.fillStyle = this.textColorInput.value;
                this.ctx.font = `bold ${this.getFontSize()}px ${this.fontStyleSelect.value}`;
                this.ctx.textAlign = this.textAlignSelect.value;
                this.ctx.textBaseline = 'middle';
                
                
                // Calculate vertical position
                let y = canvasHeight / 2;
                
                // Calculate line positions
                const lineSpacing = this.getFontSize() * this.lineHeightMultiplier;
                const startY = y - (this.lines.length - 1) * lineSpacing / 2;
                
                // Draw lines with sequential animation and per-line properties
                this.lines.forEach((line, index) => {
                    const lineProps = this.lineProperties[index] || this.getDefaultLineProperties();
                    const lineStartTime = this.getLineStartTime(index);
                    
                    if (this.animationTime >= lineStartTime) {
                        // Calculate animation progress using per-line animation speed
                        let animationProgress = 1;
                        const animationDuration = this.fadeInDuration / (lineProps.speed * (lineProps.animationSpeed || 1.0));
                        if (this.animationTime < lineStartTime + animationDuration) {
                            // Animation in progress
                            const progress = (this.animationTime - lineStartTime) / animationDuration;
                            animationProgress = Math.min(1, progress);
                        }
                        // No fade out - lines stay visible once they appear
                        
                        // Get animation transform based on animation type
                        const transform = this.getAnimationTransform(
                            lineProps.animationType || 'fade-in',
                            animationProgress,
                            canvasWidth,
                            canvasHeight
                        );
                        
                        // Set per-line text properties with improved rendering
                        console.log(`Preview Line ${index} color:`, lineProps.color, 'font:', lineProps.fontFamily, 'style:', lineProps.fontStyle);
                        this.ctx.fillStyle = lineProps.color;
                        this.ctx.font = `${lineProps.fontStyle} ${lineProps.fontWeight} ${this.getFontSize()}px ${lineProps.fontFamily}`;
                        this.ctx.textAlign = lineProps.textAlign;
                        this.ctx.textBaseline = 'middle';
                        
                        // Calculate per-line text position based on alignment
                        let x;
                        switch (lineProps.textAlign) {
                            case 'left':
                                x = canvasWidth * 0.1;
                                break;
                            case 'right':
                                x = canvasWidth * 0.9;
                                break;
                            default: // center
                                x = canvasWidth / 2;
                                break;
                        }
                        
                        this.ctx.textRenderingOptimization = 'optimizeQuality';
                        this.ctx.fontKerning = 'normal';
                        
                        // Apply stroke if specified
                        if (lineProps.strokeWidth > 0) {
                            this.ctx.strokeStyle = lineProps.strokeColor;
                            this.ctx.lineWidth = lineProps.strokeWidth;
                        }
                        
                        // Save context for transforms
                        this.ctx.save();
                        
                        // Apply animation transforms
                        const textX = x + transform.translateX;
                        const textY = startY + index * lineSpacing + transform.translateY;
                        
                        this.ctx.globalAlpha = transform.alpha;
                        
                        // Apply scaling and rotation transforms
                        if (transform.scaleX !== 1 || transform.scaleY !== 1 || transform.rotation !== 0) {
                            this.ctx.translate(textX, textY);
                            this.ctx.scale(transform.scaleX, transform.scaleY);
                            if (transform.rotation !== 0) {
                                this.ctx.rotate(transform.rotation);
                            }
                            
                            // Handle typewriter effect
                            if (lineProps.animationType === 'typewriter' && animationProgress < 1) {
                                const visibleChars = Math.floor(line.length * animationProgress);
                                const visibleText = line.substring(0, visibleChars);
                                
                                // Draw stroke first if specified
                                if (lineProps.strokeWidth > 0) {
                                    this.ctx.strokeText(visibleText, 0, 0);
                                }
                                // Draw fill text
                                this.ctx.fillText(visibleText, 0, 0);
                            } else {
                                // Draw stroke first if specified
                                if (lineProps.strokeWidth > 0) {
                                    this.ctx.strokeText(line, 0, 0);
                                }
                                // Draw fill text
                                this.ctx.fillText(line, 0, 0);
                            }
                        } else {
                            // Handle typewriter effect without transforms
                            if (lineProps.animationType === 'typewriter' && animationProgress < 1) {
                                const visibleChars = Math.floor(line.length * animationProgress);
                                const visibleText = line.substring(0, visibleChars);
                                
                                // Draw stroke first if specified
                                if (lineProps.strokeWidth > 0) {
                                    this.ctx.strokeText(visibleText, textX, textY);
                                }
                                // Draw fill text
                                this.ctx.fillText(visibleText, textX, textY);
                            } else {
                                // Draw stroke first if specified
                                if (lineProps.strokeWidth > 0) {
                                    this.ctx.strokeText(line, textX, textY);
                                }
                                // Draw fill text
                                this.ctx.fillText(line, textX, textY);
                            }
                        }
                        
                        // Restore context
                        this.ctx.restore();
                    }
                });
                
            }

            updateExportStatus(message, show = true) {
                this.exportStatusText.textContent = message;
                this.exportStatus.style.display = show ? 'inline-flex' : 'none';
            }

            startExport() {
                if (this.isExporting) {
                    console.warn('Export already in progress');
                    return;
                }
                
                const text = this.textInput.value.trim();
                if (!text) {
                    alert('Please enter some text before exporting');
                    return;
                }
                
                // Calculate duration based on sequential line animations
                const lines = text.split('\n').filter(line => line.trim() !== '');
                let totalAnimationTime = 0;
                lines.forEach((line, index) => {
                    const lineProps = this.lineProperties[index] || this.getDefaultLineProperties();
                    const animationDuration = this.fadeInDuration / (lineProps.speed * (lineProps.animationSpeed || 1.0));
                    const lineDelay = this.lineDuration / lineProps.speed;
                    
                    if (index === 0) {
                        totalAnimationTime = animationDuration + lineDelay;
                    } else {
                        totalAnimationTime += animationDuration + lineDelay;
                    }
                });
                const exportDuration = totalAnimationTime / this.animationSpeed;
                const totalDuration = exportDuration + this.endDelay;
                console.log(`Exporting ${lines.length} lines at ${this.animationSpeed}x speed, duration: ${totalDuration} seconds`);

                // Set export state
                this.isExporting = true;
                this.shouldLoop = false; // Disable looping during export

                // Disable export button during recording
                this.exportBtn.disabled = true;
                this.exportBtn.innerHTML = '<span>🔴 Recording...</span>';
                this.updateExportStatus('Initializing 4K ultra high-quality recording...');

                const exportCanvas = document.createElement('canvas');
                const exportCtx = exportCanvas.getContext('2d');
                
                exportCanvas.width = 3840;  // 4K width (16:9) - stable resolution
                exportCanvas.height = 2160; // 4K height (16:9) - stable resolution
                
                console.log(`Export canvas: ${exportCanvas.width}x${exportCanvas.height} (16:9) for ${lines.length} lines`);
                
                const devicePixelRatio = window.devicePixelRatio || 1;
                exportCtx.scale(devicePixelRatio, devicePixelRatio);
                exportCtx.imageSmoothingEnabled = true;
                exportCtx.imageSmoothingQuality = 'high';
                
                this.drawHighQualityExportFrame(exportCtx, exportCanvas.width / devicePixelRatio, exportCanvas.height / devicePixelRatio, 0);
                
                const imageData = exportCtx.getImageData(0, 0, exportCanvas.width, exportCanvas.height);
                const hasContent = imageData.data.some(pixel => pixel !== 0);
                console.log('Canvas has content:', hasContent);
                
                exportCanvas.style.position = 'absolute';
                exportCanvas.style.left = '-9999px';
                exportCanvas.style.top = '-9999px';
                document.body.appendChild(exportCanvas);
                
                let stream = exportCanvas.captureStream(60); // 60fps
                console.log('Export canvas stream created:', stream);
                console.log('Export canvas dimensions:', exportCanvas.width, 'x', exportCanvas.height);

                let options = {};
                
                // Try MP4 codecs first with high bitrates (QuickTime compatible)
                const mp4Codecs = [
                    'video/mp4;codecs=avc1.42E01E', // H.264 Baseline Profile - most compatible
                    'video/mp4;codecs=avc1.4D401E', // H.264 Main Profile
                    'video/mp4;codecs=h264',
                    'video/mp4'
                ];
                
                for (const codec of mp4Codecs) {
                    if (MediaRecorder.isTypeSupported(codec)) {
                        options = {
                            mimeType: codec,
                            videoBitsPerSecond: 15000000 // 15 Mbps for better compatibility
                        };
                        break;
                    }
                }
                
                // Fallback to WebM if MP4 not supported
                if (!options.mimeType) {
                    const webmCodecs = [
                        'video/webm;codecs=vp9',
                        'video/webm;codecs=vp8',
                        'video/webm'
                    ];
                    
                    for (const codec of webmCodecs) {
                        if (MediaRecorder.isTypeSupported(codec)) {
                            options = {
                                mimeType: codec,
                                videoBitsPerSecond: 8000000 // 8 Mbps for VP9
                            };
                            break;
                        }
                    }
                }
                
                // Final fallback
                if (!options.mimeType) {
                    options = {
                        mimeType: 'video/webm',
                        videoBitsPerSecond: 2000000 // 2 Mbps fallback
                    };
                }

                let recorder;
                try {
                    console.log('Creating MediaRecorder with options:', options);
                    console.log('Stream details:', stream);
                    console.log('Stream tracks:', stream.getTracks());
                    recorder = new MediaRecorder(stream, options);
                    console.log('MediaRecorder created successfully');
                } catch (error) {
                    console.error('Failed to create MediaRecorder:', error);
                    alert('Export failed: MediaRecorder not supported. Please try a different browser.');
                    this.exportBtn.disabled = false;
                    this.exportBtn.innerHTML = '<span>🎬 Export as MP4</span>';
                    this.isExporting = false;
                    this.shouldLoop = true; // Re-enable looping
                    document.body.removeChild(exportCanvas);
                    return;
                }
                
                let chunks = [];

                recorder.ondataavailable = e => {
                    if (e.data.size > 0) {
                        chunks.push(e.data);
                    }
                };
                
                recorder.onerror = (event) => {
                    console.error('MediaRecorder error:', event.error);
                    alert('Export failed: Recording error occurred. Please try again.');
                    this.exportBtn.disabled = false;
                    this.exportBtn.innerHTML = '<span>🎬 Export as MP4</span>';
                    this.isExporting = false;
                    this.shouldLoop = true; // Re-enable looping
                    document.body.removeChild(exportCanvas);
                };
                
                recorder.onstart = () => {
                    this.updateExportStatus(`Recording 4K ultra high-quality text animation...`);
                    console.log('4K ultra high-quality recording started with mimeType:', options.mimeType);
                    this.animationTime = 0;
                    this.startHighQualityRendering(exportCtx, exportCanvas.width / devicePixelRatio, exportCanvas.height / devicePixelRatio, totalDuration);
                };
                
                recorder.onstop = () => {
                    this.updateExportStatus('Processing video...');
                    console.log('Recording stopped, chunks:', chunks.length);
                    
                    // Cleanup: Stop the canvas stream to free resources
                    stream.getTracks().forEach(track => track.stop());
                    document.body.removeChild(exportCanvas);
                    
                    if (chunks.length === 0) {
                        console.error('No video data recorded');
                        alert('Export failed: No video data was recorded. Please try again.');
                        this.exportBtn.disabled = false;
                        this.exportBtn.innerHTML = '<span>🎬 Export as MP4</span>';
                        this.isExporting = false;
                        this.shouldLoop = true; // Re-enable looping
                        return;
                    }
                    
                    // Determine file extension based on the actual mime type
                    const mimeType = recorder.mimeType || 'video/webm';
                    const isMP4 = mimeType.includes('mp4') || mimeType.includes('h264') || mimeType.includes('avc1');
                    const fileExtension = isMP4 ? 'mp4' : 'webm';
                    const fileName = `text-green-screen-4k-${Date.now()}.${fileExtension}`;
                    
                    let blob = new Blob(chunks, { type: mimeType });
                    console.log('Blob created:', blob.size, 'bytes, type:', blob.type);
                    
                    let url = URL.createObjectURL(blob);
                    let a = document.createElement('a');
                    a.href = url;
                    a.download = fileName;
                    a.click();
                    
                    // Cleanup: Revoke URL immediately after download
                    setTimeout(() => {
                        URL.revokeObjectURL(url);
                    }, 1000);

                    // Cleanup: Clear references to prevent memory leaks
                    recorder = null;
                    chunks = null;
                    stream = null;

                    // Re-enable export button
                    this.exportBtn.disabled = false;
                    this.exportBtn.innerHTML = '<span>🎬 Export as MP4</span>';
                    this.updateExportStatus('4K ultra high-quality video exported successfully! ✨');
                    
                    // Reset export state
                    this.isExporting = false;
                    this.shouldLoop = true; // Re-enable looping
                    
                    setTimeout(() => this.updateExportStatus('', false), 3000);
                };

                // Start recording with a small delay to ensure everything is ready
                setTimeout(() => {
                    try {
                recorder.start();
                    } catch (error) {
                        console.error('Failed to start recording:', error);
                        alert('Export failed: Could not start recording. Please try again.');
                        this.exportBtn.disabled = false;
                        this.exportBtn.innerHTML = '<span>🎬 Export as MP4</span>';
                        this.isExporting = false;
                        this.shouldLoop = true; // Re-enable looping
                        document.body.removeChild(exportCanvas);
                    }
                }, 100);
                
                // Export for calculated duration based on number of lines
                setTimeout(() => {
                    this.updateExportStatus('Finishing recording...');
                    if (recorder.state === 'recording') {
                        recorder.stop();
                    }
                }, totalDuration * 1000); // Convert to milliseconds
            }

            startHighQualityRendering(exportCtx, width, height, totalDuration) {
                const startTime = Date.now();
                const renderFrame = () => {
                    if (!this.isExporting) return;
                    const currentTime = Date.now();
                    const elapsed = (currentTime - startTime) / 1000;
                    const animationTime = elapsed * this.animationSpeed;
                    this.drawHighQualityExportFrame(exportCtx, width, height, animationTime);
                    if (elapsed < totalDuration) {
                        requestAnimationFrame(renderFrame);
                    }
                };
                renderFrame();
            }

            drawHighQualityExportFrame(ctx, width, height, animationTime) {
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                ctx.textRenderingOptimization = 'optimizeQuality';
                ctx.fontKerning = 'normal';
                ctx.fontVariantCaps = 'normal';
                ctx.textBaseline = 'middle';
                ctx.textAlign = 'center';
                
                ctx.fillStyle = '#00FF00';
                ctx.fillRect(0, 0, width, height);
                
                const text = this.textInput.value.trim();
                if (!text) return;
                const lines = text.split('\n').filter(line => line.trim() !== '');
                if (lines.length === 0) return;
                
                const fontSize = this.getFontSizeForExport(width, height);
                const lineHeight = fontSize * this.lineHeightMultiplier;
                
                const totalTextHeight = lines.length * lineHeight;
                const startY = height / 2 - totalTextHeight / 2 + lineHeight / 2;
                
                // Draw lines with EXACT same sequential logic as preview canvas
                lines.forEach((line, index) => {
                    const lineProps = this.lineProperties[index] || this.getDefaultLineProperties();
                    const lineStartTime = this.getLineStartTime(index);
                    
                    // Check if this line should be visible (same logic as preview)
                    if (animationTime < lineStartTime) {
                        return; // Line not visible yet
                    }
                    
                    // Calculate animation progress using per-line animation speed (same logic as preview)
                    let animationProgress = 1;
                    const animationDuration = this.fadeInDuration / (lineProps.speed * (lineProps.animationSpeed || 1.0));
                    if (animationTime < lineStartTime + animationDuration) {
                        // Animation in progress (same logic as preview)
                        const progress = (animationTime - lineStartTime) / animationDuration;
                        animationProgress = Math.min(1, progress);
                    }
                    // No fade out - lines stay visible once they appear (same as preview)
                    
                    // Get animation transform based on animation type (same as preview)
                    const transform = this.getAnimationTransform(
                        lineProps.animationType || 'fade-in',
                        animationProgress,
                        width,
                        height
                    );
                    
                    // Set per-line text properties with improved rendering (same as preview)
                    console.log(`Export Line ${index} color:`, lineProps.color, 'font:', lineProps.fontFamily);
                    ctx.fillStyle = lineProps.color;
                    ctx.font = `${lineProps.fontStyle} ${lineProps.fontWeight} ${fontSize}px ${lineProps.fontFamily}`;
                    ctx.textAlign = lineProps.textAlign;
                    ctx.textBaseline = 'middle';
                    
                    // Calculate per-line text position based on alignment (same as preview)
                    let x;
                    switch (lineProps.textAlign) {
                        case 'left':
                            x = width * 0.1;
                            break;
                        case 'right':
                            x = width * 0.9;
                            break;
                        default: // center
                            x = width / 2;
                            break;
                    }
                    
                    ctx.textRenderingOptimization = 'optimizeQuality';
                    ctx.fontKerning = 'normal';
                    ctx.fontVariantCaps = 'normal';
                    ctx.imageSmoothingEnabled = true;
                    ctx.imageSmoothingQuality = 'high';
                    
                    // Apply stroke if specified (same as preview)
                    if (lineProps.strokeWidth > 0) {
                        ctx.strokeStyle = lineProps.strokeColor;
                        ctx.lineWidth = lineProps.strokeWidth;
                    }
                    
                    // Save context for transforms (same as preview)
                    ctx.save();
                    
                    // Apply animation transforms (same as preview)
                    const textX = x + transform.translateX;
                    const textY = startY + index * lineHeight + transform.translateY;
                    
                    ctx.globalAlpha = transform.alpha;
                    
                    // Apply scaling and rotation transforms (same as preview)
                    if (transform.scaleX !== 1 || transform.scaleY !== 1 || transform.rotation !== 0) {
                        ctx.translate(textX, textY);
                        ctx.scale(transform.scaleX, transform.scaleY);
                        if (transform.rotation !== 0) {
                            ctx.rotate(transform.rotation);
                        }
                        
                        // Handle typewriter effect (same as preview)
                        if (lineProps.animationType === 'typewriter' && animationProgress < 1) {
                            const visibleChars = Math.floor(line.length * animationProgress);
                            const visibleText = line.substring(0, visibleChars);
                            
                            // Draw stroke first if specified
                            if (lineProps.strokeWidth > 0) {
                                ctx.strokeText(visibleText, 0, 0);
                            }
                            // Draw fill text
                            ctx.fillText(visibleText, 0, 0);
                        } else {
                            // Draw stroke first if specified
                            if (lineProps.strokeWidth > 0) {
                                ctx.strokeText(line, 0, 0);
                            }
                            // Draw fill text
                            ctx.fillText(line, 0, 0);
                        }
                    } else {
                        // Handle typewriter effect without transforms (same as preview)
                        if (lineProps.animationType === 'typewriter' && animationProgress < 1) {
                            const visibleChars = Math.floor(line.length * animationProgress);
                            const visibleText = line.substring(0, visibleChars);
                            
                            // Draw stroke first if specified
                            if (lineProps.strokeWidth > 0) {
                                ctx.strokeText(visibleText, textX, textY);
                            }
                            // Draw fill text
                            ctx.fillText(visibleText, textX, textY);
                        } else {
                            // Draw stroke first if specified
                            if (lineProps.strokeWidth > 0) {
                                ctx.strokeText(line, textX, textY);
                            }
                            // Draw fill text
                            ctx.fillText(line, textX, textY);
                        }
                    }
                    
                    // Restore context (same as preview)
                    ctx.restore();
                });
            }

            getFontSizeForExport(width, height) {
                const text = this.textInput.value.trim();
                const lines = text.split('\n').filter(line => line.trim() !== '');
                const lineCount = Math.max(1, lines.length);
                
                const baseFontSize = 300; // Optimized for 4K resolution
                
                // Calculate optimal font size based on vertical space
                const availableHeight = height * 0.8;
                const lineSpacing = this.lineHeightMultiplier;
                const optimalFontSize = (availableHeight / lineCount) / lineSpacing;
                
                let fontSize;
                if (lineCount <= 1) {
                    fontSize = baseFontSize;
                } else if (lineCount <= 3) {
                    fontSize = Math.min(baseFontSize * 0.9, optimalFontSize);
                } else if (lineCount <= 5) {
                    fontSize = Math.min(baseFontSize * 0.75, optimalFontSize);
                } else if (lineCount <= 10) {
                    fontSize = Math.min(baseFontSize * 0.6, optimalFontSize);
                } else if (lineCount <= 15) {
                    fontSize = Math.min(baseFontSize * 0.5, optimalFontSize);
                } else if (lineCount <= 20) {
                    fontSize = Math.min(baseFontSize * 0.45, optimalFontSize);
                } else {
                    fontSize = Math.min(baseFontSize * 0.4, optimalFontSize);
                }
                
                fontSize = fontSize * this.lineHeightMultiplier;
                
                // Now check horizontal constraints for each line and adjust if needed
                const availableWidth = width * 0.9; // Use 90% of canvas width for safety margin
                let maxRequiredFontSize = fontSize;
                
                lines.forEach((line, index) => {
                    const lineProps = this.lineProperties[index] || this.getDefaultLineProperties();
                    
                    // Create a temporary canvas context to measure text width for export
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.font = `${lineProps.fontStyle} ${lineProps.fontWeight} ${fontSize}px ${lineProps.fontFamily}`;
                    
                    const textWidth = tempCtx.measureText(line).width;
                    
                    if (textWidth > availableWidth) {
                        // Calculate the maximum font size that would fit this line
                        const scaleFactor = availableWidth / textWidth;
                        const adjustedFontSize = fontSize * scaleFactor;
                        maxRequiredFontSize = Math.min(maxRequiredFontSize, adjustedFontSize);
                    }
                });
                
                fontSize = maxRequiredFontSize;
                
                const minFontSize = 60; // Optimized for 4K resolution
                fontSize = Math.max(minFontSize, fontSize);
                return fontSize;
            }
        }

        // Initialize the app when the page loads
        let textGreenScreen = null;
        
        document.addEventListener('DOMContentLoaded', () => {
            textGreenScreen = new TextGreenScreen();
        });
        
        // Clean up when page is unloaded to prevent memory leaks
        window.addEventListener('beforeunload', () => {
            if (textGreenScreen) {
                textGreenScreen.stopAnimation();
                textGreenScreen = null;
            }
        });
    </script>
    <script src="shared.js"></script>
</body>
</html>
