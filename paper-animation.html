<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vintage Paper Effect</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        :root {
            --primary: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --secondary: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            --success: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            --surface: rgba(255, 255, 255, 0.05);
            --surface-hover: rgba(255, 255, 255, 0.1);
            --text-primary: #ffffff;
            --text-secondary: #a0a0a0;
            --border: rgba(255, 255, 255, 0.1);
            --shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            --radius: 16px;
        }
        
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            color: var(--text-primary);
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 32px;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
        }

        .title {
            font-size: 2.5rem;
            font-weight: 700;
            background: var(--primary);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin: 0 0 8px 0;
            letter-spacing: -0.02em;
        }

        .subtitle {
            font-size: 1.1rem;
            color: var(--text-secondary);
            font-weight: 400;
            margin: 0;
        }

        .upload-section {
            text-align: center;
            margin-bottom: 20px;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            cursor: pointer;
            background: var(--secondary);
            color: white;
            padding: 16px 32px;
            border-radius: 12px;
            border: none;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 16px rgba(245, 87, 108, 0.3);
            font-family: inherit;
            letter-spacing: 0.01em;
            position: relative;
            overflow: hidden;
        }

        .file-input-wrapper:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(245, 87, 108, 0.4);
        }

        .file-input-wrapper::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .file-input-wrapper:hover::before {
            left: 100%;
        }

        #fileInput {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .canvas-container {
            position: relative;
            border-radius: var(--radius);
            overflow: hidden;
            box-shadow: var(--shadow);
            background: var(--surface);
            padding: 20px;
            backdrop-filter: blur(20px);
            border: 1px solid var(--border);
        }

        #canvas {
            background: #00FF00;
            border-radius: 12px;
            max-width: 90vw;
            max-height: 50vh;
            width: auto;
            height: auto;
            display: block;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        }

        .instructions {
            width: 100%;
            max-width: 900px;
            background: var(--surface);
            border-left: 4px solid #667eea;
            padding: 32px;
            border-radius: var(--radius);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
        }

        .instructions h3 {
            color: var(--text-primary);
            margin-top: 0;
            font-weight: 600;
        }

        .instructions ul {
            color: var(--text-secondary);
            line-height: 1.6;
            margin: 0;
            padding-left: 20px;
        }

        .animation-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 20px;
            width: 100%;
            max-width: 900px;
            padding: 32px;
            background: var(--surface);
            border-radius: var(--radius);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
        }

        .animation-controls h3 {
            color: var(--text-primary);
            margin-top: 0;
            margin-bottom: 20px;
            font-weight: 600;
            grid-column: 1 / -1;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-group label {
            color: var(--text-primary);
            font-weight: 600;
            font-size: 14px;
            letter-spacing: 0.01em;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: var(--surface-hover);
            outline: none;
            -webkit-appearance: none;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--secondary);
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .control-group input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--secondary);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .control-group span {
            color: var(--text-secondary);
            font-weight: 500;
            font-size: 14px;
        }

        .export-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 20px;
            width: 100%;
            max-width: 900px;
            padding: 32px;
            background: var(--surface);
            border-radius: var(--radius);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
        }

        .export-section h3 {
            color: var(--text-primary);
            margin-top: 0;
            margin-bottom: 20px;
            font-weight: 600;
            grid-column: 1 / -1;
        }

        .export-button {
            padding: 16px 32px;
            font-size: 16px;
            font-weight: 600;
            border: none;
            border-radius: 12px;
            background: var(--secondary);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 16px rgba(245, 87, 108, 0.3);
            font-family: inherit;
            letter-spacing: 0.01em;
            position: relative;
            overflow: hidden;
            grid-column: 1 / -1;
            margin-top: 15px;
        }

        .export-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(245, 87, 108, 0.4);
        }

        .export-button:active {
            transform: translateY(0);
        }

        .export-button:disabled {
            background: linear-gradient(135deg, #4a4a4a 0%, #2a2a2a 100%);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .export-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .export-button:hover::before {
            left: 100%;
        }

        .export-status {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: var(--surface);
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            margin-top: 16px;
            border: 1px solid var(--border);
            color: var(--text-primary);
            grid-column: 1 / -1;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--success);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        input[type="number"], select {
            padding: 12px 16px;
            font-size: 14px;
            border: 1px solid var(--border);
            border-radius: 12px;
            background: var(--surface);
            color: var(--text-primary);
            font-family: inherit;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        input[type="number"]:focus, select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
            background: rgba(255, 255, 255, 0.08);
        }

        input[type="number"]:hover, select:hover {
            border-color: rgba(255, 255, 255, 0.2);
            background: var(--surface-hover);
        }

        select {
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%23a0a0a0' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
            background-position: right 12px center;
            background-repeat: no-repeat;
            background-size: 16px;
            padding-right: 40px;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .container > * {
            animation: fadeIn 0.6s ease forwards;
        }

        .container > *:nth-child(2) { animation-delay: 0.1s; }
        .container > *:nth-child(3) { animation-delay: 0.2s; }
        .container > *:nth-child(4) { animation-delay: 0.3s; }
        .container > *:nth-child(5) { animation-delay: 0.4s; }

        @media (max-width: 768px) {
            .title {
                font-size: 2rem;
            }
            
            .animation-controls,
            .export-section {
                grid-template-columns: 1fr;
                padding: 24px;
            }
            
            .export-button {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="title">üèõÔ∏è Vintage Paper Effect</h1>
            <p class="subtitle">Transform images into stunning vintage paper animations with torn edges</p>
        </div>
        
        <div class="upload-section">
            <label for="fileInput" class="file-input-wrapper">
                üì∏ Upload Image
                <input type="file" id="fileInput" accept="image/png,image/jpg,image/jpeg,image/gif" />
            </label>
        </div>

        <div class="canvas-container">
            <canvas id="canvas" width="3840" height="2160"></canvas>
            <video id="backgroundVideo" style="display: none;" loop muted>
                <source src="paper.mp4" type="video/mp4">
            </video>
        </div>

        <div class="animation-controls">
            <h3>üé¨ Animation Controls</h3>
            <div class="control-group">
                <label for="speedSlider">Speed</label>
                <input type="range" id="speedSlider" min="0.5" max="3" step="0.1" value="1">
                <span id="speedValue">1.0x</span>
            </div>
            <div class="control-group">
                <label for="rotationSlider">Rotation (¬∞)</label>
                <input type="range" id="rotationSlider" min="0" max="10" step="0.5" value="3">
                <span id="rotationValue">3¬∞</span>
            </div>
            <div class="control-group">
                <label for="floatSlider">Float Distance</label>
                <input type="range" id="floatSlider" min="5" max="30" step="1" value="15">
                <span id="floatValue">15px</span>
            </div>

            <div class="control-group">
                <label for="jitterSlider">Jitter</label>
                <input type="range" id="jitterSlider" min="0" max="3" step="0.1" value="1">
                <span id="jitterValue">1.0</span>
            </div>
            <div class="control-group">
                <label for="edgeThicknessSlider">Edge Thickness</label>
                <input type="range" id="edgeThicknessSlider" min="0" max="100" step="1" value="8">
                <span id="edgeThicknessValue">8px</span>
            </div>
            <div class="control-group">
                <label for="unfoldToggle">Unfold Effect</label>
                <input type="checkbox" id="unfoldToggle" checked>
                <span>Enable paper unfolding animation</span>
            </div>
        </div>

        <div class="export-section">
            <h3>üìπ Export Settings</h3>
            <div class="control-group">
                <label for="durationInput">Duration (seconds)</label>
                <input type="number" id="durationInput" value="5" min="1" max="30" step="0.5">
            </div>
            <div class="control-group">
                <label for="exportFormat">Export Format</label>
                <select id="exportFormat">
                    <option value="webm">WebM (Fast)</option>
                    <option value="mp4">MP4 (High Quality)</option>
                </select>
            </div>
            <div class="control-group">
                <label for="qualitySelect">Quality</label>
                <select id="qualitySelect">
                    <option value="high">High Quality (8 Mbps)</option>
                    <option value="medium">Medium Quality (5 Mbps)</option>
                    <option value="low">Low Quality (3 Mbps)</option>
                </select>
            </div>
            <button id="exportBtn" class="export-button">
                <span>üé¨ Export Animation</span>
            </button>
            <div id="exportStatus" class="export-status" style="display: none;">
                <div class="status-dot"></div>
                <span id="exportStatusText">Ready to export</span>
            </div>
        </div>

        <div class="instructions">
            <h3>How to use:</h3>
            <ul>
                <li>Click "Upload Image" to select an image file</li>
                <li>The image will be placed on vintage paper with torn edges</li>
                <li>Your video plays inside the torn paper area</li>
                <li>The effect is applied instantly on the canvas</li>
                <li>Try different images to see various torn paper effects</li>
                <li>Adjust animation settings above to customize the floating effect</li>
            </ul>
        </div>
    </div>

    <script>
        class VintagePaperEffect {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.fileInput = document.getElementById('fileInput');
                this.backgroundVideo = document.getElementById('backgroundVideo');
                this.paperTexture = null;
                
                // Animation properties
                this.animationId = null;
                this.startTime = Date.now();
                this.currentImage = null;
                this.currentTornEdgeMask = null;
                this.currentTornPaperTexture = null;
                this.imagePosition = { x: 0, y: 0 };
                
                // Animation settings
                this.animationSettings = {
                    speed: 1.0,
                    rotationRange: 3,
                    floatDistance: 15,
                    jitterAmount: 1.0,
                    edgeThickness: 8
                };
                
                // Debounce timer for edge thickness updates
                this.edgeThicknessTimer = null;
                
                this.init();
            }

            init() {
                this.fileInput.addEventListener('change', this.handleFileUpload.bind(this));
                this.createPaperTexture();
                this.setupAnimationControls();
                this.setupExportControls();
                this.setupBackgroundVideo();
                this.drawInitialState();
            }

            setupAnimationControls() {
                const controls = {
                    speed: { slider: 'speedSlider', value: 'speedValue', suffix: 'x' },
                    rotationRange: { slider: 'rotationSlider', value: 'rotationValue', suffix: '¬∞' },
                    floatDistance: { slider: 'floatSlider', value: 'floatValue', suffix: 'px' },
                    jitterAmount: { slider: 'jitterSlider', value: 'jitterValue', suffix: '' },
                    edgeThickness: { slider: 'edgeThicknessSlider', value: 'edgeThicknessValue', suffix: 'px' }
                };

                Object.keys(controls).forEach(setting => {
                    const slider = document.getElementById(controls[setting].slider);
                    const valueSpan = document.getElementById(controls[setting].value);
                    
                    slider.addEventListener('input', (e) => {
                        const value = parseFloat(e.target.value);
                        this.animationSettings[setting] = value;
                        valueSpan.textContent = value + controls[setting].suffix;
                        
                        // Debounced update for edge thickness changes
                        if (setting === 'edgeThickness' && this.currentImage) {
                            // Clear existing timer
                            if (this.edgeThicknessTimer) {
                                clearTimeout(this.edgeThicknessTimer);
                            }
                            
                            // Set new timer for delayed update
                            this.edgeThicknessTimer = setTimeout(() => {
                                this.regenerateTornEdges();
                            }, 300); // 300ms delay
                        }
                    });
                });
            }

            setupExportControls() {
                this.exportBtn = document.getElementById('exportBtn');
                this.exportStatus = document.getElementById('exportStatus');
                this.exportStatusText = document.getElementById('exportStatusText');
                this.durationInput = document.getElementById('durationInput');
                this.qualitySelect = document.getElementById('qualitySelect');
                this.exportFormatSelect = document.getElementById('exportFormat');

                this.exportBtn.addEventListener('click', this.startExport.bind(this));
            }

            regenerateTornEdges() {
                if (!this.currentImage) return;
                
                // Get current image dimensions
                const width = this.currentImage.width;
                const height = this.currentImage.height;
                
                // Detect object outline
                const objectOutline = this.detectObjectOutline(this.currentImage);
                
                // Create new torn edge mask with current edge thickness
                const tornEdgeMask = this.createTornEdgeFromOutline(objectOutline, width, height);
                
                // Update the current torn edge mask
                this.currentTornEdgeMask = tornEdgeMask;
            }

            setupBackgroundVideo() {
                // Start the background video when it's ready
                this.backgroundVideo.addEventListener('loadeddata', () => {
                    console.log('Video loaded successfully, starting playback');
                    this.backgroundVideo.play();
                });
                
                // Handle video errors
                this.backgroundVideo.addEventListener('error', (e) => {
                    console.warn('Background video could not be loaded:', e);
                });
                
                // Log video loading progress
                this.backgroundVideo.addEventListener('loadstart', () => {
                    console.log('Video loading started');
                });
                
                this.backgroundVideo.addEventListener('canplay', () => {
                    console.log('Video can play, ready state:', this.backgroundVideo.readyState);
                });
            }

            startAnimation() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
                this.startTime = Date.now();
                this.animate();
            }

            stopAnimation() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
            }

            animate() {
                const currentTime = Date.now();
                const elapsed = (currentTime - this.startTime) * this.animationSettings.speed;
                
                if (this.currentImage) {
                    this.renderAnimatedFrame(elapsed);
                }
                
                this.animationId = requestAnimationFrame(() => this.animate());
            }

            calculateTransforms(elapsed) {
                // Convert elapsed time to seconds
                const timeInSeconds = elapsed / 1000;
                
                // Fixed scale (no breathing effect)
                const scale = 1;
                
                // Rotation swaying (sine wave with different frequency)
                const rotation = Math.sin(timeInSeconds * 1.5) * (this.animationSettings.rotationRange * Math.PI / 180);
                
                // Vertical float (sine wave)
                const floatOffset = Math.sin(timeInSeconds * 1.2) * this.animationSettings.floatDistance;
                
                // Organic jitter (multiple sine waves with different frequencies)
                const jitterX = (Math.sin(timeInSeconds * 3.7) + Math.sin(timeInSeconds * 5.1) * 0.5) 
                    * this.animationSettings.jitterAmount;
                const jitterY = (Math.cos(timeInSeconds * 4.3) + Math.cos(timeInSeconds * 6.2) * 0.5) 
                    * this.animationSettings.jitterAmount;
                
                return {
                    scale,
                    rotation,
                    translateX: jitterX,
                    translateY: floatOffset + jitterY
                };
            }

            renderAnimatedFrame(elapsed) {
                // Enable high-quality rendering
                this.ctx.imageSmoothingEnabled = true;
                this.ctx.imageSmoothingQuality = 'high';
                
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw green screen background
                this.ctx.fillStyle = '#00FF00';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                if (!this.currentImage) return;

                // Calculate transforms
                const transforms = this.calculateTransforms(elapsed);
                
                // Apply transforms and render layers
                this.renderAnimatedLayers(transforms);
            }

            renderAnimatedLayers(transforms) {
                const { scale, rotation, translateX, translateY } = transforms;
                const { x, y } = this.imagePosition;
                
                // Calculate center point for rotation and scaling
                const centerX = x + this.currentImage.width / 2;
                const centerY = y + this.currentImage.height / 2;
                
                // Layer 1: Background paper is already drawn
                
                // Layer 2: Video inside torn paper area (animated)
                this.ctx.save();
                this.ctx.translate(centerX + translateX, centerY + translateY);
                this.ctx.rotate(rotation);
                this.ctx.scale(scale, scale);
                this.ctx.translate(-centerX, -centerY);
                
                // Create temporary canvas for video with torn mask
                const videoMaskCanvas = document.createElement('canvas');
                videoMaskCanvas.width = this.currentImage.width;
                videoMaskCanvas.height = this.currentImage.height;
                const videoMaskCtx = videoMaskCanvas.getContext('2d');
                
                // Draw video frame
                if (this.backgroundVideo.readyState >= 2) {
                    videoMaskCtx.drawImage(this.backgroundVideo, 0, 0, this.currentImage.width, this.currentImage.height);
                } else {
                    // Fallback: draw a colored rectangle to show the video area
                    videoMaskCtx.fillStyle = '#FF0000';
                    videoMaskCtx.fillRect(0, 0, this.currentImage.width, this.currentImage.height);
                }
                
                // Apply torn edge mask to video
                videoMaskCtx.globalCompositeOperation = 'destination-in';
                videoMaskCtx.drawImage(this.currentTornEdgeMask, 0, 0);
                
                // Draw masked video to main canvas
                this.ctx.drawImage(videoMaskCanvas, x, y);
                
                // Layer 4: Original image on top (animated)
                this.ctx.drawImage(this.currentImage, x, y);
                
                // Layer 5: Subtle shadow (animated)
                this.ctx.globalCompositeOperation = 'multiply';
                this.ctx.globalAlpha = 0.2;
                this.ctx.drawImage(this.currentImage, x + 2, y + 2);
                
                this.ctx.restore();
            }

            createPaperTexture() {
                // Create vintage paper texture using canvas
                const textureCanvas = document.createElement('canvas');
                textureCanvas.width = this.canvas.width;
                textureCanvas.height = this.canvas.height;
                const textureCtx = textureCanvas.getContext('2d');

                // Base paper color with gradient
                const gradient = textureCtx.createLinearGradient(0, 0, textureCanvas.width, textureCanvas.height);
                gradient.addColorStop(0, '#F4E4BC');
                gradient.addColorStop(0.5, '#E8D5B7');
                gradient.addColorStop(1, '#D2B48C');
                
                textureCtx.fillStyle = gradient;
                textureCtx.fillRect(0, 0, textureCanvas.width, textureCanvas.height);

                // Add paper texture noise
                const imageData = textureCtx.getImageData(0, 0, textureCanvas.width, textureCanvas.height);
                const data = imageData.data;

                for (let i = 0; i < data.length; i += 4) {
                    const noise = (Math.random() - 0.5) * 30;
                    data[i] = Math.max(0, Math.min(255, data[i] + noise));     // Red
                    data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + noise)); // Green
                    data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + noise)); // Blue
                }

                textureCtx.putImageData(imageData, 0, 0);

                // Add aging spots and stains
                for (let i = 0; i < 50; i++) {
                    const x = Math.random() * textureCanvas.width;
                    const y = Math.random() * textureCanvas.height;
                    const radius = Math.random() * 8 + 2;
                    
                    textureCtx.globalAlpha = Math.random() * 0.3 + 0.1;
                    textureCtx.fillStyle = '#8B4513';
                    textureCtx.beginPath();
                    textureCtx.arc(x, y, radius, 0, Math.PI * 2);
                    textureCtx.fill();
                }

                textureCtx.globalAlpha = 1;
                this.paperTexture = textureCanvas;
            }



            handleFileUpload(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        this.processImage(img);
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }

            processImage(img) {
                // Stop any existing animation
                this.stopAnimation();

                // Calculate image dimensions to fit canvas while maintaining aspect ratio
                // Use larger dimensions for better quality
                const maxWidth = this.canvas.width * 0.6;
                const maxHeight = this.canvas.height * 0.6;
                
                let { width, height } = this.calculateImageDimensions(img, maxWidth, maxHeight);
                
                const x = (this.canvas.width - width) / 2;
                const y = (this.canvas.height - height) / 2;

                // Step 1: Create image canvas with proper alpha and high quality
                const imageCanvas = document.createElement('canvas');
                imageCanvas.width = width;
                imageCanvas.height = height;
                const imageCtx = imageCanvas.getContext('2d');
                
                // Enable high-quality rendering for image processing
                imageCtx.imageSmoothingEnabled = true;
                imageCtx.imageSmoothingQuality = 'high';
                
                imageCtx.drawImage(img, 0, 0, width, height);

                // Step 2: Detect alpha channel and create object outline
                const objectOutline = this.detectObjectOutline(imageCanvas);

                // Step 3: Create torn paper edge mask around the object
                const tornEdgeMask = this.createTornEdgeFromOutline(objectOutline, width, height);

                // Step 4: Create torn paper texture for edges
                const tornPaperTexture = this.createTornPaperTexture(width, height);

                // Store current image data for animation
                this.currentImage = imageCanvas;
                this.currentTornEdgeMask = tornEdgeMask;
                this.currentTornPaperTexture = tornPaperTexture;
                this.imagePosition = { x, y };

                // Start animation
                this.startAnimation();
            }

            detectObjectOutline(imageCanvas) {
                const ctx = imageCanvas.getContext('2d');
                const imageData = ctx.getImageData(0, 0, imageCanvas.width, imageCanvas.height);
                const data = imageData.data;
                const width = imageCanvas.width;
                const height = imageCanvas.height;
                
                // Create outline map - true where pixels are on the edge of opaque areas
                const outline = new Array(width * height).fill(false);
                
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        const index = (y * width + x) * 4;
                        const alpha = data[index + 3]; // Alpha channel
                        
                        // If this pixel is opaque or semi-opaque
                        if (alpha > 50) {
                            // Check if any neighboring pixel is transparent (edge detection)
                            const neighbors = [
                                data[((y-1) * width + x) * 4 + 3],     // top
                                data[((y+1) * width + x) * 4 + 3],     // bottom
                                data[(y * width + (x-1)) * 4 + 3],     // left
                                data[(y * width + (x+1)) * 4 + 3],     // right
                                data[((y-1) * width + (x-1)) * 4 + 3], // top-left
                                data[((y-1) * width + (x+1)) * 4 + 3], // top-right
                                data[((y+1) * width + (x-1)) * 4 + 3], // bottom-left
                                data[((y+1) * width + (x+1)) * 4 + 3]  // bottom-right
                            ];
                            
                            // If any neighbor is transparent, this is an edge pixel
                            const isEdge = neighbors.some(neighborAlpha => neighborAlpha <= 50);
                            outline[y * width + x] = isEdge;
                        }
                    }
                }
                
                return { outline, width, height };
            }

            createTornEdgeFromOutline(objectOutline, width, height) {
                const maskCanvas = document.createElement('canvas');
                maskCanvas.width = width;
                maskCanvas.height = height;
                const maskCtx = maskCanvas.getContext('2d');
                
                // Start with transparent mask
                maskCtx.clearRect(0, 0, width, height);
                
                const { outline } = objectOutline;
                const edgeExpansion = this.animationSettings.edgeThickness; // Use edge thickness setting
                
                // Create expanded torn edge mask
                const expandedMask = new Array(width * height).fill(false);
                
                // For each outline pixel, create a torn edge expansion
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const index = y * width + x;
                        if (outline[index]) {
                            // Apply torn edge effect around this outline pixel
                            this.expandOutlinePixel(expandedMask, x, y, width, height, edgeExpansion);
                        }
                    }
                }
                
                // Convert expanded mask to canvas
                maskCtx.fillStyle = 'white';
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        if (expandedMask[y * width + x]) {
                            maskCtx.fillRect(x, y, 1, 1);
                        }
                    }
                }
                
                return maskCanvas;
            }

            expandOutlinePixel(expandedMask, centerX, centerY, width, height, maxExpansion) {
                // Create more jagged, irregular torn expansion like in the reference image
                const steps = 24; // Fewer steps for more jagged look
                
                for (let i = 0; i < steps; i++) {
                    const angle = (i / steps) * Math.PI * 2;
                    
                    // More aggressive random variations for jagged edges
                    const baseExpansion = maxExpansion * 0.8;
                    const noise1 = Math.sin(angle * 4 + centerX * 0.15) * 3;
                    const noise2 = Math.cos(angle * 6 + centerY * 0.15) * 3;
                    const randomNoise = (Math.random() - 0.5) * 8; // More random variation
                    const expansion = Math.max(2, baseExpansion + noise1 + noise2 + randomNoise);
                    
                    // Create jagged tears with varying intensity
                    const jaggedSteps = Math.ceil(expansion * 1.2);
                    for (let j = 0; j <= jaggedSteps; j++) {
                        const progress = j / jaggedSteps;
                        let currentExpansion = expansion * progress;
                        
                        // Add micro-jitter for more realistic paper tear
                        const microJitter = (Math.random() - 0.5) * 2;
                        currentExpansion += microJitter;
                        
                        const x = Math.round(centerX + Math.cos(angle) * currentExpansion);
                        const y = Math.round(centerY + Math.sin(angle) * currentExpansion);
                        
                        if (x >= 0 && x < width && y >= 0 && y < height) {
                            expandedMask[y * width + x] = true;
                            
                            // Add surrounding pixels for thicker torn edge
                            for (let dx = -1; dx <= 1; dx++) {
                                for (let dy = -1; dy <= 1; dy++) {
                                    const nx = x + dx;
                                    const ny = y + dy;
                                    if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                        if (Math.random() > 0.3) { // 70% chance to fill surrounding
                                            expandedMask[ny * width + nx] = true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            createTornPaperTexture(width, height) {
                const textureCanvas = document.createElement('canvas');
                textureCanvas.width = width;
                textureCanvas.height = height;
                const textureCtx = textureCanvas.getContext('2d');
                
                // Enable high-quality rendering for texture creation
                textureCtx.imageSmoothingEnabled = true;
                textureCtx.imageSmoothingQuality = 'high';

                // Create white/cream paper texture like in the image
                const gradient = textureCtx.createRadialGradient(
                    width/2, height/2, 0,
                    width/2, height/2, Math.max(width, height)/2
                );
                gradient.addColorStop(0, '#FFFFFF');
                gradient.addColorStop(0.3, '#F8F8F8');
                gradient.addColorStop(0.7, '#F0F0F0');
                gradient.addColorStop(1, '#E8E8E8');
                
                textureCtx.fillStyle = gradient;
                textureCtx.fillRect(0, 0, width, height);

                // Add subtle paper fiber texture
                const imageData = textureCtx.getImageData(0, 0, width, height);
                const data = imageData.data;

                for (let i = 0; i < data.length; i += 4) {
                    const noise = (Math.random() - 0.5) * 15; // Reduced noise for cleaner look
                    data[i] = Math.max(0, Math.min(255, data[i] + noise));     // Red
                    data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + noise)); // Green
                    data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + noise)); // Blue
                }

                textureCtx.putImageData(imageData, 0, 0);

                // Add very subtle gray shadows near edges for depth
                textureCtx.globalAlpha = 0.1;
                textureCtx.fillStyle = '#CCCCCC';
                
                // Add subtle edge shadows
                for (let i = 0; i < 8; i++) {
                    const x = Math.random() * width;
                    const y = Math.random() * height;
                    const radius = Math.random() * 3 + 1;
                    
                    textureCtx.beginPath();
                    textureCtx.arc(x, y, radius, 0, Math.PI * 2);
                    textureCtx.fill();
                }

                textureCtx.globalAlpha = 1;
                return textureCanvas;
            }

            renderLayers(imageCanvas, tornEdgeMask, tornPaperTexture, x, y) {
                // Layer 1: Background paper is already drawn
                
                // Layer 2: Torn paper edge texture where the mask is
                this.ctx.save();
                this.ctx.globalCompositeOperation = 'source-over';
                
                // Create temporary canvas for masked torn texture
                const maskedTexture = document.createElement('canvas');
                maskedTexture.width = tornPaperTexture.width;
                maskedTexture.height = tornPaperTexture.height;
                const maskedCtx = maskedTexture.getContext('2d');
                
                // Draw torn texture
                maskedCtx.drawImage(tornPaperTexture, 0, 0);
                
                // Apply mask to texture
                maskedCtx.globalCompositeOperation = 'destination-in';
                maskedCtx.drawImage(tornEdgeMask, 0, 0);
                
                // Draw masked texture to main canvas
                this.ctx.drawImage(maskedTexture, x, y);
                
                // Layer 3: Original image on top
                this.ctx.drawImage(imageCanvas, x, y);
                
                // Layer 4: Subtle shadow
                this.ctx.globalCompositeOperation = 'multiply';
                this.ctx.globalAlpha = 0.2;
                this.ctx.drawImage(imageCanvas, x + 2, y + 2);
                
                this.ctx.restore();
            }



            calculateImageDimensions(img, maxWidth, maxHeight) {
                let { width, height } = img;
                
                // Scale down if necessary
                if (width > maxWidth || height > maxHeight) {
                    const scale = Math.min(maxWidth / width, maxHeight / height);
                    width *= scale;
                    height *= scale;
                }
                
                return { width, height };
            }

            drawInitialState() {
                // Enable high-quality rendering
                this.ctx.imageSmoothingEnabled = true;
                this.ctx.imageSmoothingQuality = 'high';
                
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw green screen background
                this.ctx.fillStyle = '#00FF00';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Add instruction text with better quality
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.font = 'bold 48px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.strokeStyle = '#000000';
                this.ctx.lineWidth = 4;
                this.ctx.strokeText('Upload an image to see the vintage paper effect!', 
                    this.canvas.width / 2, this.canvas.height / 2);
                this.ctx.fillText('Upload an image to see the vintage paper effect!', 
                    this.canvas.width / 2, this.canvas.height / 2);
            }

            destroy() {
                this.stopAnimation();
                // Clean up event listeners if needed
            }

            updateExportStatus(message, show = true) {
                this.exportStatusText.textContent = message;
                this.exportStatus.style.display = show ? 'inline-flex' : 'none';
            }

            startExport() {
                if (!this.currentImage) {
                    alert('Please upload an image first before exporting');
                    return;
                }

                const duration = parseFloat(this.durationInput.value);
                if (isNaN(duration) || duration <= 0) {
                    alert('Please enter a valid duration');
                    return;
                }

                // Disable export button during recording
                this.exportBtn.disabled = true;
                this.exportBtn.innerHTML = '<span>üî¥ Recording...</span>';
                this.updateExportStatus('Initializing recording...');

                // Capture canvas stream with high quality settings
                let stream = this.canvas.captureStream(60); // 60fps

                // Get export format and quality settings
                const exportFormat = this.exportFormatSelect.value;
                const quality = this.qualitySelect.value;
                
                // Try different codec options based on format preference
                let options = {};
                
                if (exportFormat === "mp4") {
                    // Try MP4 codecs first
                    const mp4Codecs = [
                        'video/mp4;codecs=h264',
                        'video/mp4',
                        'video/webm;codecs=h264'
                    ];
                    
                    for (const codec of mp4Codecs) {
                        if (MediaRecorder.isTypeSupported(codec)) {
                            options = {
                                mimeType: codec,
                                videoBitsPerSecond: quality === 'high' ? 8000000 : quality === 'medium' ? 5000000 : 3000000
                            };
                            break;
                        }
                    }
                }
                
                // Fallback to WebM if MP4 not supported or WebM preferred
                if (!options.mimeType) {
                    const webmCodecs = [
                        'video/webm;codecs=vp9',
                        'video/webm;codecs=vp8',
                        'video/webm'
                    ];
                    
                    for (const codec of webmCodecs) {
                        if (MediaRecorder.isTypeSupported(codec)) {
                            options = {
                                mimeType: codec,
                                videoBitsPerSecond: exportFormat === "mp4" ? 
                                    (quality === 'high' ? 8000000 : quality === 'medium' ? 5000000 : 3000000) :
                                    (quality === 'high' ? 5000000 : quality === 'medium' ? 3000000 : 2000000)
                            };
                            break;
                        }
                    }
                }
                
                // Final fallback
                if (!options.mimeType) {
                    options = {
                        mimeType: 'video/webm',
                        videoBitsPerSecond: quality === 'high' ? 3000000 : quality === 'medium' ? 2000000 : 1000000
                    };
                }

                let recorder = new MediaRecorder(stream, options);
                let chunks = [];

                recorder.ondataavailable = e => chunks.push(e.data);
                recorder.onstop = () => {
                    this.updateExportStatus('Processing video...');
                    let blob = new Blob(chunks, { type: 'video/webm' });
                    
                    // Determine file extension based on the actual mime type
                    const mimeType = recorder.mimeType || 'video/webm';
                    const isMP4 = mimeType.includes('mp4') || mimeType.includes('h264');
                    const fileExtension = isMP4 ? 'mp4' : 'webm';
                    const fileName = `vintage-paper-animation-${Date.now()}.${fileExtension}`;
                    
                    let url = URL.createObjectURL(blob);
                    let a = document.createElement('a');
                    a.href = url;
                    a.download = fileName;
                    a.click();
                    URL.revokeObjectURL(url);

                    // Re-enable export button
                    this.exportBtn.disabled = false;
                    this.exportBtn.innerHTML = '<span>üé¨ Export Animation</span>';
                    this.updateExportStatus('Video exported successfully! ‚ú®');
                    setTimeout(() => this.updateExportStatus('', false), 3000);
                };

                recorder.start();
                this.updateExportStatus(`Recording animation (${duration}s)`);

                // Start the animation for the specified duration
                const startTime = Date.now();
                const durationMs = duration * 1000;

                // Ensure animation is running
                if (!this.animationId) {
                    this.startAnimation();
                }

                // Stop recording after duration
                setTimeout(() => {
                    this.updateExportStatus('Finishing recording...');
                    recorder.stop();
                }, durationMs);
            }
        }

        // Initialize the app when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new VintagePaperEffect();
        });
    </script>
</body>
</html>